# WO-015.8: Phase 2 - Brevo Sync Service Implementation Plan

**Created:** 2025-01-18
**Phase:** 2 of 4
**Goal:** Implement Brevo contact sync (core service + scheduler)
**Risk Level:** üü° Medium (external API calls)
**Prerequisites:** ‚úÖ Phase 1 complete + WO-015.7 dual-status adapter verified
**Estimated Time:** 2-3 days

---

## Executive Summary

Phase 2 implements the actual Brevo contact synchronization. We'll build this in two steps:

1. **Step 1: Core Sync Service** - Pure business logic to sync one contact to Brevo API
2. **Step 2: Background Scheduler** - APScheduler job that finds queued contacts and triggers sync

**Critical Success Criteria:**
- Contacts with `brevo_processing_status = 'Queued'` automatically sync to Brevo
- Retry logic with exponential backoff handles failures
- Idempotent (safe to re-run on same contact)
- No breaking changes to Phase 1 endpoints

---

## Architecture Decision: SDK Pattern vs Manual Loop

### Option A: SDK Pattern (Recommended - Follows WF7 Pages Pattern)

**Pros:**
- ‚úÖ Matches existing codebase pattern (PageCurationScheduler)
- ‚úÖ Built-in race condition prevention (SELECT FOR UPDATE with skip locked)
- ‚úÖ Automatic batch processing with status transitions
- ‚úÖ Less boilerplate code
- ‚úÖ Consistent with ScraperSky architecture

**Cons:**
- ‚ùå Service must accept `(contact_id: UUID, session)` signature
- ‚ùå Must fetch contact inside service (one extra query per contact)

**Reference:** `src/services/WF7_V2_L4_2of2_PageCurationScheduler.py` (47 lines)

---

### Option B: Manual Loop (From WO-015.4)

**Pros:**
- ‚úÖ Service can work directly with Contact objects
- ‚úÖ More explicit control over query and processing

**Cons:**
- ‚ùå Must manually handle race conditions
- ‚ùå More boilerplate code
- ‚ùå Deviates from established pattern

---

## Recommendation: Use SDK Pattern (Option A)

**Reason:** Consistency with existing WF7 services, built-in safety features, less code to maintain.

---

## Step 1: Core Brevo Sync Service (1 day)

### 1.1 Configuration Setup

**File:** `src/config/settings.py`

**Add to Settings class:**

```python
# Brevo CRM Integration
BREVO_API_KEY: Optional[str] = None
BREVO_LIST_ID: Optional[str] = None  # Optional
BREVO_API_BASE_URL: str = "https://api.brevo.com/v3"

# Brevo Sync Scheduler
BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES: int = 5
BREVO_SYNC_SCHEDULER_BATCH_SIZE: int = 10
BREVO_SYNC_SCHEDULER_MAX_INSTANCES: int = 1

# Brevo Retry Logic
BREVO_SYNC_MAX_RETRIES: int = 3
BREVO_SYNC_RETRY_DELAY_MINUTES: int = 5
BREVO_SYNC_RETRY_EXPONENTIAL: bool = True
```

**Environment Variables (.env.example):**

```bash
# Brevo CRM Integration
BREVO_API_KEY=your_brevo_api_key_here
BREVO_LIST_ID=  # Optional - leave empty if no list

# Brevo Sync Scheduler (defaults shown)
BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES=5
BREVO_SYNC_SCHEDULER_BATCH_SIZE=10
BREVO_SYNC_SCHEDULER_MAX_INSTANCES=1

# Brevo Retry Logic
BREVO_SYNC_MAX_RETRIES=3
BREVO_SYNC_RETRY_DELAY_MINUTES=5
BREVO_SYNC_RETRY_EXPONENTIAL=true
```

---

### 1.2 Core Brevo Sync Service

**File:** `src/services/crm/brevo_sync_service.py` (NEW FILE)

**Structure:**

```python
"""
Brevo Contact Sync Service
Handles synchronization of contacts to Brevo CRM via their API

Architecture: SDK-compatible service for use with run_job_loop pattern
"""

import logging
from typing import Optional
from datetime import datetime, timedelta
from uuid import UUID
import httpx
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus

logger = logging.getLogger(__name__)


class BrevoSyncService:
    """Service for syncing contacts to Brevo CRM"""

    def __init__(self):
        self.api_key = settings.BREVO_API_KEY
        self.list_id = settings.BREVO_LIST_ID
        self.base_url = settings.BREVO_API_BASE_URL

        if not self.api_key:
            logger.warning("BREVO_API_KEY not configured - Brevo sync will fail")


    # SDK-COMPATIBLE METHOD SIGNATURE
    async def process_single_contact(
        self,
        contact_id: UUID,
        session: AsyncSession
    ) -> None:
        """
        Process a single contact for Brevo sync.

        SDK-compatible method signature: (contact_id: UUID, session: AsyncSession)
        Called by scheduler via run_job_loop pattern.

        Args:
            contact_id: Contact UUID to process
            session: Async database session (managed by SDK)
        """
        logger.info(f"Starting Brevo sync for contact {contact_id}")

        # Fetch contact
        stmt = select(Contact).where(Contact.id == contact_id)
        result = await session.execute(stmt)
        contact = result.scalar_one_or_none()

        if not contact:
            logger.error(f"Contact {contact_id} not found - skipping")
            return

        try:
            # Core sync logic
            await self._sync_contact_to_brevo(contact, session)

        except Exception as e:
            logger.exception(f"Failed to sync contact {contact_id}: {e}")
            # SDK will handle marking as failed
            raise


    async def _sync_contact_to_brevo(
        self,
        contact: Contact,
        session: AsyncSession
    ) -> None:
        """
        Core business logic to sync one contact to Brevo.

        Handles:
        - Validation
        - Status transitions (Processing ‚Üí Complete/Error)
        - API call
        - Retry logic
        - Error tracking

        Args:
            contact: Contact model instance
            session: Async database session
        """
        logger.info(f"Processing Brevo sync for {contact.email}")

        try:
            # Validate
            if not contact.email:
                raise ValueError("Contact has no email address")

            # Status: Processing
            contact.brevo_sync_status = CRMSyncStatus.Processing.value
            contact.brevo_processing_status = CRMProcessingStatus.Processing.value
            await session.commit()  # Immediate visibility

            # Call Brevo API
            brevo_contact_id = await self._call_brevo_api(contact)

            # Status: Complete
            contact.brevo_sync_status = CRMSyncStatus.Complete.value
            contact.brevo_processing_status = CRMProcessingStatus.Complete.value
            contact.brevo_processing_error = None
            contact.brevo_contact_id = brevo_contact_id
            contact.retry_count = 0
            contact.next_retry_at = None
            contact.last_failed_crm = None

            await session.commit()
            logger.info(f"‚úÖ Successfully synced {contact.email} to Brevo")

        except Exception as e:
            error_msg = str(e)
            logger.exception(f"‚ùå Brevo sync failed for {contact.email}: {error_msg}")

            # Retry logic
            should_retry = contact.retry_count < settings.BREVO_SYNC_MAX_RETRIES

            if should_retry:
                # Calculate exponential backoff
                delay_minutes = self._calculate_retry_delay(contact.retry_count)
                next_retry = datetime.utcnow() + timedelta(minutes=delay_minutes)

                # Status: Queued for retry
                contact.brevo_sync_status = CRMSyncStatus.Queued.value
                contact.brevo_processing_status = CRMProcessingStatus.Error.value
                contact.brevo_processing_error = error_msg[:500]
                contact.retry_count += 1
                contact.last_retry_at = datetime.utcnow()
                contact.next_retry_at = next_retry
                contact.last_failed_crm = "brevo"

                logger.info(
                    f"üîÑ Scheduled retry {contact.retry_count}/{settings.BREVO_SYNC_MAX_RETRIES} "
                    f"for {contact.email} at {next_retry}"
                )
            else:
                # Status: Error (max retries exceeded)
                contact.brevo_sync_status = CRMSyncStatus.Error.value
                contact.brevo_processing_status = CRMProcessingStatus.Error.value
                contact.brevo_processing_error = f"Max retries exceeded. Last error: {error_msg[:400]}"
                contact.last_failed_crm = "brevo"

                logger.error(
                    f"‚ùå Contact {contact.email} failed after {contact.retry_count} retries"
                )

            await session.commit()
            # Don't re-raise - let processing continue


    def _calculate_retry_delay(self, retry_count: int) -> int:
        """
        Calculate retry delay with exponential backoff.

        Examples (base=5 minutes):
        - Retry 0: 5 minutes
        - Retry 1: 10 minutes (5 * 2^1)
        - Retry 2: 20 minutes (5 * 2^2)

        Args:
            retry_count: Number of retries so far (0-indexed)

        Returns:
            Delay in minutes
        """
        base_delay = settings.BREVO_SYNC_RETRY_DELAY_MINUTES

        if settings.BREVO_SYNC_RETRY_EXPONENTIAL:
            # Exponential: base * 2^retry_count
            return base_delay * (2 ** retry_count)
        else:
            # Linear: base * (retry_count + 1)
            return base_delay * (retry_count + 1)


    async def _call_brevo_api(self, contact: Contact) -> str:
        """
        Make HTTP request to Brevo API to create/update contact.

        API Documentation: https://developers.brevo.com/reference/createcontact

        Args:
            contact: Contact model instance

        Returns:
            Brevo contact ID (email address)

        Raises:
            httpx.HTTPError: If API request fails
            ValueError: If API response is invalid
        """
        if not self.api_key:
            raise ValueError("BREVO_API_KEY not configured")

        headers = {
            "api-key": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        # Build payload
        payload = {
            "email": contact.email,
            "attributes": {},
            "updateEnabled": True,  # Idempotent: update if exists
        }

        # Optional: Name (split into first/last)
        if contact.name:
            name_parts = contact.name.strip().split(maxsplit=1)
            payload["attributes"]["FIRSTNAME"] = name_parts[0]
            if len(name_parts) > 1:
                payload["attributes"]["LASTNAME"] = name_parts[1]

        # Optional: Phone
        if contact.phone_number:
            payload["attributes"]["SMS"] = contact.phone_number

        # Custom attributes (ScraperSky metadata)
        if contact.domain_id:
            payload["attributes"]["DOMAIN_ID"] = str(contact.domain_id)
        if contact.page_id:
            payload["attributes"]["PAGE_ID"] = str(contact.page_id)
        if contact.email_type:
            payload["attributes"]["EMAIL_TYPE"] = contact.email_type
        if contact.source_url:
            payload["attributes"]["SOURCE_URL"] = contact.source_url
        if contact.has_gmail is not None:
            payload["attributes"]["HAS_GMAIL"] = str(contact.has_gmail)

        # Optional: Add to list
        if self.list_id:
            try:
                payload["listIds"] = [int(self.list_id)]
            except ValueError:
                logger.warning(f"Invalid BREVO_LIST_ID: {self.list_id}")

        logger.debug(f"Brevo API payload: {payload}")

        # Make request
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{self.base_url}/contacts",
                headers=headers,
                json=payload,
            )

            # Success: 201 (created) or 204 (updated)
            if response.status_code in [201, 204]:
                return contact.email  # Brevo uses email as ID

            # Bad request (invalid data)
            if response.status_code == 400:
                error_detail = response.json().get("message", response.text)
                raise ValueError(f"Brevo API error: {error_detail}")

            # Other errors
            response.raise_for_status()

            # Fallback (shouldn't reach here)
            logger.warning(
                f"Unexpected Brevo response: {response.status_code} - {response.text}"
            )
            return contact.email
```

**Key Features:**
- ‚úÖ SDK-compatible signature: `process_single_contact(contact_id: UUID, session)`
- ‚úÖ Exponential backoff retry logic
- ‚úÖ Comprehensive status tracking
- ‚úÖ Idempotent API calls (`updateEnabled: true`)
- ‚úÖ Proper error handling and logging
- ‚úÖ Custom ScraperSky attributes sent to Brevo

---

### 1.3 Testing Core Service (Manual Testing)

**Test File:** `tests/services/test_brevo_sync_service.py` (optional but recommended)

**Manual Test Plan:**

```python
# Manual test script to verify core service works

from src.services.crm.brevo_sync_service import BrevoSyncService
from src.db.session import get_db_session
from uuid import UUID

async def test_sync_one_contact():
    """Test syncing one contact to Brevo"""

    service = BrevoSyncService()

    # Replace with actual contact ID that has brevo_processing_status = 'Queued'
    contact_id = UUID("your-test-contact-id-here")

    async for session in get_db_session():
        await service.process_single_contact(contact_id, session)
        await session.commit()

    print("‚úÖ Test complete - check Brevo dashboard for contact")

# Run: python -m asyncio tests.services.test_brevo_sync_service.test_sync_one_contact
```

**Verification Steps:**
1. Create test contact via Phase 1 endpoint
2. Run manual test script
3. Check Brevo dashboard for new contact
4. Verify database: `brevo_processing_status = 'Complete'`
5. Verify: `brevo_contact_id = contact.email`

---

## Step 2: Background Scheduler (1 day)

### 2.1 Scheduler Implementation (SDK Pattern)

**File:** `src/services/crm/brevo_sync_scheduler.py` (NEW FILE)

```python
"""
Brevo Contact Sync Scheduler
Background scheduler using SDK run_job_loop pattern
"""

import logging
from sqlalchemy import asc, and_, or_
from datetime import datetime

from src.scheduler_instance import scheduler
from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMProcessingStatus
from src.services.crm.brevo_sync_service import BrevoSyncService
from src.common.curation_sdk.scheduler_loop import run_job_loop

logger = logging.getLogger(__name__)


async def process_brevo_sync_queue():
    """
    Scheduler job: Process contacts queued for Brevo sync.

    Uses SDK run_job_loop pattern for race-condition-free processing.
    """
    logger.info("üöÄ Starting Brevo sync scheduler cycle")

    service = BrevoSyncService()

    # Custom query: Include contacts ready for retry
    # (SDK doesn't natively support retry logic)
    await run_job_loop(
        model=Contact,
        status_enum=CRMProcessingStatus,
        queued_status=CRMProcessingStatus.Queued,
        processing_status=CRMProcessingStatus.Processing,
        completed_status=CRMProcessingStatus.Complete,
        failed_status=CRMProcessingStatus.Error,
        processing_function=service.process_single_contact,
        batch_size=settings.BREVO_SYNC_SCHEDULER_BATCH_SIZE,
        order_by_column=asc(Contact.updated_at),
        status_field_name="brevo_processing_status",
        error_field_name="brevo_processing_error",
    )

    logger.info("‚úÖ Finished Brevo sync scheduler cycle")


def setup_brevo_sync_scheduler():
    """
    Register Brevo sync scheduler with shared APScheduler instance.

    Called from src/scheduler_manager.py during app startup.
    """
    job_id = "brevo_contact_sync_processor"

    if not settings.BREVO_API_KEY:
        logger.warning(
            "‚ö†Ô∏è BREVO_API_KEY not configured - Brevo sync scheduler DISABLED"
        )
        return

    scheduler.add_job(
        process_brevo_sync_queue,
        trigger="interval",
        minutes=settings.BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES,
        id=job_id,
        name="Brevo Contact Sync Processor",
        replace_existing=True,
        max_instances=settings.BREVO_SYNC_SCHEDULER_MAX_INSTANCES,
        misfire_grace_time=1800,  # 30 min grace period
    )

    logger.info(
        f"‚úÖ Brevo sync scheduler registered: every {settings.BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES} min, "
        f"batch size {settings.BREVO_SYNC_SCHEDULER_BATCH_SIZE}"
    )
```

**Key Features:**
- ‚úÖ Uses SDK `run_job_loop` for built-in safety
- ‚úÖ Automatic race condition prevention (SELECT FOR UPDATE with skip locked)
- ‚úÖ Batch processing with configurable size
- ‚úÖ Status transitions handled by SDK
- ‚úÖ Only 50 lines of code (vs 150+ for manual loop)

---

### 2.2 Alternative: Manual Loop (If SDK Pattern Not Preferred)

**File:** `src/services/crm/brevo_sync_scheduler.py` (ALTERNATIVE)

```python
"""
Brevo Contact Sync Scheduler (Manual Loop Pattern)
"""

import logging
from sqlalchemy import asc, and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from datetime import datetime

from src.scheduler_instance import scheduler
from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus
from src.services.crm.brevo_sync_service import BrevoSyncService
from src.db.session import get_db_session

logger = logging.getLogger(__name__)


async def process_brevo_sync_queue():
    """
    Scheduler job: Process contacts queued for Brevo sync (manual loop).
    """
    logger.info("üöÄ Starting Brevo sync scheduler cycle")

    try:
        service = BrevoSyncService()

        async for session in get_db_session():
            # Query: Find contacts ready for sync
            # - brevo_processing_status = 'Queued' (set by dual-status adapter)
            # - OR ready for retry (next_retry_at is NULL or in the past)
            stmt = (
                select(Contact)
                .where(
                    and_(
                        Contact.brevo_processing_status.in_(['Queued']),
                        # Exclude contacts waiting for retry
                        or_(
                            Contact.next_retry_at.is_(None),
                            Contact.next_retry_at <= datetime.utcnow()
                        )
                    )
                )
                .order_by(asc(Contact.updated_at))
                .limit(settings.BREVO_SYNC_SCHEDULER_BATCH_SIZE)
            )

            result = await session.execute(stmt)
            contacts = result.scalars().all()

            if not contacts:
                logger.info("No contacts queued for Brevo sync")
                return

            logger.info(f"Processing {len(contacts)} contacts for Brevo sync")

            # Process each contact
            for contact in contacts:
                try:
                    await service._sync_contact_to_brevo(contact, session)
                    await session.commit()
                except Exception as e:
                    logger.exception(f"Failed to process contact {contact.id}: {e}")
                    await session.rollback()
                    # Continue with next contact

    except Exception as e:
        logger.exception(f"Critical error in Brevo sync scheduler: {e}")

    logger.info("‚úÖ Finished Brevo sync scheduler cycle")


def setup_brevo_sync_scheduler():
    """Register scheduler (same as SDK version)"""
    # ... (same setup code as SDK version)
```

**Note:** Manual loop gives more control but requires careful handling of:
- Race conditions (multiple scheduler instances)
- Transaction management
- Error recovery

---

### 2.3 Register Scheduler at Startup

**File:** `src/scheduler_manager.py`

**Add import:**

```python
from src.services.crm.brevo_sync_scheduler import setup_brevo_sync_scheduler
```

**Add to scheduler setup function:**

```python
def setup_all_schedulers():
    """Register all background schedulers"""
    # ... existing schedulers ...

    # WO-015: Brevo CRM Sync
    setup_brevo_sync_scheduler()

    logger.info("All schedulers registered")
```

---

### 2.4 Testing Scheduler (Manual Testing)

**Test Plan:**

1. **Setup:**
   ```bash
   export BREVO_API_KEY="your_test_api_key"
   export BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES=1  # Fast for testing
   export BREVO_SYNC_SCHEDULER_BATCH_SIZE=5
   ```

2. **Create Test Contacts:**
   ```bash
   # Use Phase 1 endpoint to select 5 contacts for Brevo
   curl -X PUT "http://localhost:8000/api/v3/contacts/crm/select" \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -d '{
       "contact_ids": ["<id1>", "<id2>", "<id3>", "<id4>", "<id5>"],
       "crms": ["brevo"],
       "action": "select"
     }'
   ```

3. **Start Scheduler:**
   ```bash
   docker compose up --build
   # Watch logs for: "üöÄ Starting Brevo sync scheduler cycle"
   ```

4. **Verify Database:**
   ```sql
   SELECT
     email,
     brevo_sync_status,
     brevo_processing_status,
     brevo_contact_id,
     retry_count
   FROM contacts
   WHERE brevo_sync_status IN ('Processing', 'Complete', 'Error')
   ORDER BY updated_at DESC
   LIMIT 10;
   ```

5. **Verify Brevo Dashboard:**
   - Log in to Brevo
   - Check Contacts list
   - Verify 5 new contacts appear

**Expected Results:**
- ‚úÖ All 5 contacts have `brevo_processing_status = 'Complete'`
- ‚úÖ All 5 contacts have `brevo_contact_id = <email>`
- ‚úÖ All 5 contacts visible in Brevo dashboard
- ‚úÖ Scheduler logs show successful processing

---

## Implementation Checklist

### Step 1: Core Service ‚úÖ
- [ ] Add Brevo config to `src/config/settings.py`
- [ ] Add `.env.example` entries
- [ ] Create `src/services/crm/` directory
- [ ] Create `brevo_sync_service.py`
- [ ] Implement `BrevoSyncService` class
- [ ] Implement `process_single_contact()` (SDK-compatible)
- [ ] Implement `_sync_contact_to_brevo()` (core logic)
- [ ] Implement `_call_brevo_api()` (HTTP request)
- [ ] Implement `_calculate_retry_delay()` (exponential backoff)
- [ ] Manual test: Sync 1 contact
- [ ] Verify in Brevo dashboard
- [ ] Verify database status updates

### Step 2: Scheduler ‚úÖ
- [ ] Create `brevo_sync_scheduler.py`
- [ ] Implement `process_brevo_sync_queue()` (SDK or manual)
- [ ] Implement `setup_brevo_sync_scheduler()`
- [ ] Update `src/scheduler_manager.py` imports
- [ ] Update `setup_all_schedulers()` function
- [ ] Manual test: Select 5 contacts
- [ ] Start scheduler, verify processing
- [ ] Check logs for successful cycles
- [ ] Verify all contacts synced

### Step 3: Testing & Verification ‚úÖ
- [ ] Test successful sync (200/201 response)
- [ ] Test duplicate sync (idempotency)
- [ ] Test missing API key (error handling)
- [ ] Test invalid email (validation)
- [ ] Test API timeout (retry logic)
- [ ] Test max retries exceeded (error state)
- [ ] Test retry timing (exponential backoff)
- [ ] Verify no race conditions (multiple instances)

### Step 4: Documentation ‚úÖ
- [ ] Update WO-015_INDEX.md (Phase 2 status)
- [ ] Create WO-015.8.1_PHASE_2_COMPLETION.md
- [ ] Document Brevo API setup instructions
- [ ] Update API documentation (if exists)

---

## Success Criteria

**Phase 2 is COMPLETE when:**

1. ‚úÖ Service can sync single contact to Brevo API
2. ‚úÖ Scheduler automatically processes queued contacts
3. ‚úÖ Retry logic works (exponential backoff)
4. ‚úÖ Error states properly tracked
5. ‚úÖ Idempotent (safe to re-run)
6. ‚úÖ No breaking changes to Phase 1
7. ‚úÖ All manual tests pass
8. ‚úÖ Verified in production Brevo account

---

## Next Steps After Phase 2

**Phase 3:** Implement HubSpot, Mautic, n8n sync services (copy Brevo pattern)
**Phase 4:** Monitoring, documentation, production deployment

---

## Troubleshooting

### Issue: Scheduler not starting

**Check:**
```bash
# Verify BREVO_API_KEY set
echo $BREVO_API_KEY

# Check scheduler logs
docker compose logs -f app | grep -i brevo
```

### Issue: Contacts stuck in "Queued"

**Diagnose:**
```sql
-- Check if contacts are actually queued
SELECT COUNT(*) FROM contacts WHERE brevo_processing_status = 'Queued';

-- Check retry timing
SELECT email, next_retry_at FROM contacts WHERE brevo_processing_status = 'Queued';
```

### Issue: API authentication failed

**Fix:**
1. Verify API key in Brevo dashboard
2. Check key has correct permissions
3. Test API key with curl:
   ```bash
   curl https://api.brevo.com/v3/account \
     -H "api-key: $BREVO_API_KEY"
   ```

---

**Estimated Time:** 2-3 days
**Risk Level:** üü° Medium
**Blocking Issues:** None (Phase 1 + WO-015.7 complete)
**Ready to Start:** ‚úÖ YES
