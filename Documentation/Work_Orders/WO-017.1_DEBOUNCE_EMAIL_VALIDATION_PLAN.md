# WO-017.1: DeBounce.io Email Validation Integration Plan

**Work Order:** WO-017.1
**Created:** 2025-11-18
**Status:** Planning
**Priority:** High
**Depends On:** WO-015 (Brevo pattern), WO-016 (HubSpot pattern)

---

## Executive Summary

Implement DeBounce.io email validation integration to verify contact email addresses **before syncing to CRMs**. This creates a quality gate that prevents syncing invalid/disposable/catch-all emails to expensive CRM platforms, improving deliverability and reducing costs.

**Strategic Value:**
```
Contact Created
  ‚Üì
DeBounce Validation ‚Üê YOU ARE HERE
  ‚Üì
If VALID ‚Üí Queue for CRM Sync (Brevo/HubSpot)
If INVALID ‚Üí Mark and skip CRM sync
```

**Pattern Reuse:** Follows proven WO-015/WO-016 dual-status adapter pattern with **added API endpoints** to address current CRM sync gap.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [DeBounce.io API Overview](#debounceioapioverview)
3. [Architecture Pattern](#architecture-pattern)
4. [Database Schema](#database-schema)
5. [Phase 1: Core Service](#phase-1-core-service)
6. [Phase 2: Scheduler](#phase-2-scheduler)
7. [Phase 3: API Endpoints](#phase-3-api-endpoints)
8. [Configuration](#configuration)
9. [Testing Strategy](#testing-strategy)
10. [Success Criteria](#success-criteria)

---

## Prerequisites

### DeBounce.io Account

**Free Tier:**
- 100 free email validations
- Good for testing
- No credit card required

**Paid Plans:**
- Pay-as-you-go: $0.008 per email
- Monthly plans: $15/month (2,000 emails)
- Enterprise: Custom pricing

**Sign Up:**
1. Go to https://debounce.io/
2. Create account
3. Navigate to API Settings
4. Copy API key (format: `db_xxxxxxxxxxxxxxxxxxxxxxxx`)

### Database Schema

**Already Complete:** Contact model exists from WO-015.2
**Need to Add:** 8 new fields for email validation

---

## DeBounce.io API Overview

### Authentication

```http
Authorization: api-key YOUR_API_KEY
Content-Type: application/json
```

API key format: `db_xxxxxxxxxxxxxxxxxxxxxxxx`

### Base URL

```
https://api.debounce.io/v1
```

### Core Endpoints

#### 1. Single Email Validation

```http
POST /v1/validate/single
Content-Type: application/json
Authorization: api-key db_xxxxxxxx

{
  "email": "user@example.com"
}

Response 200:
{
  "email": "user@example.com",
  "result": "valid",  // valid, invalid, catch-all, unknown, disposable
  "score": 95,        // 0-100 confidence score
  "reason": "",       // Explanation if invalid
  "did_you_mean": "", // Suggested correction for typos
  "disposable": false,
  "role_account": false,  // info@, admin@, etc.
  "free_email": false,    // gmail, yahoo, etc.
  "syntax_valid": true,
  "dns_valid": true,
  "smtp_valid": true
}
```

#### 2. Bulk Email Validation (Recommended for Scheduler)

```http
POST /v1/validate/bulk
Content-Type: application/json
Authorization: api-key db_xxxxxxxx

{
  "emails": [
    "user1@example.com",
    "user2@example.com",
    "user3@example.com"
  ]
}

Response 200:
{
  "results": [
    {
      "email": "user1@example.com",
      "result": "valid",
      "score": 95
    },
    {
      "email": "user2@example.com",
      "result": "disposable",
      "score": 0,
      "reason": "Temporary email provider detected"
    },
    {
      "email": "user3@example.com",
      "result": "invalid",
      "score": 0,
      "reason": "Domain does not exist"
    }
  ]
}
```

**Bulk Limits:**
- Free tier: 50 emails per request
- Paid tier: 100 emails per request
- Response time: ~5-10 seconds per batch

### Result Types

| Result | Meaning | CRM Sync Decision |
|--------|---------|-------------------|
| `valid` | Deliverable email | ‚úÖ Queue for CRM sync |
| `invalid` | Doesn't exist or bounces | ‚ùå Skip CRM sync |
| `catch-all` | Server accepts all emails | ‚ö†Ô∏è Queue with warning flag |
| `unknown` | Cannot verify (server timeout) | ‚ö†Ô∏è Queue with manual review |
| `disposable` | Temporary email (10minutemail, etc.) | ‚ùå Skip CRM sync |

### Rate Limits

**Free Tier:** 1 request per second
**Paid Tier:** 10 requests per second

**Our Strategy:** Batch validation (50 emails per 5 minutes) = ~0.016 requests/sec (well under limit)

---

## Architecture Pattern

Follows WO-015/WO-016 dual-status pattern:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User Action (API/UI) ‚Üê NEW IN WO-017                   ‚îÇ
‚îÇ  POST /api/v3/contacts/{id}/queue-validation            ‚îÇ
‚îÇ  - Marks contact.debounce_validation_status = 'Queued'  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        v
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  APScheduler (every 5 minutes)                          ‚îÇ
‚îÇ  debounce_validation_scheduler.py                       ‚îÇ
‚îÇ  - setup_debounce_validation_scheduler()                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        v
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  process_debounce_validation_queue()                    ‚îÇ
‚îÇ  - Query: debounce_processing_status = 'Queued'         ‚îÇ
‚îÇ  - Batch: 50 emails (configurable)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        v
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  run_job_loop (SDK)                                     ‚îÇ
‚îÇ  - SELECT FOR UPDATE skip_locked                        ‚îÇ
‚îÇ  - Bulk mark as 'Processing'                            ‚îÇ
‚îÇ  - Process batch via bulk API                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        v
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DeBounceValidationService.process_batch()              ‚îÇ
‚îÇ  - Collect 50 emails                                    ‚îÇ
‚îÇ  - Call DeBounce bulk API                               ‚îÇ
‚îÇ  - Update all contacts with results                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        v
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Success: debounce_validation_status = 'Complete'       ‚îÇ
‚îÇ  - Auto-queue for CRM if result = 'valid'               ‚îÇ
‚îÇ  Failure: Retry with exponential backoff (max 3)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Innovation:** Bulk processing via SDK while maintaining per-contact status tracking.

---

## Database Schema

### New Fields (Add to Contact Model)

**File:** `src/models/WF7_V2_L1_1of1_ContactModel.py`

```python
# DeBounce Email Validation (WO-017)
debounce_validation_status: Mapped[Optional[str]] = mapped_column(String, nullable=True)
debounce_processing_status: Mapped[Optional[str]] = mapped_column(String, nullable=True)
debounce_result: Mapped[Optional[str]] = mapped_column(String, nullable=True)  # valid/invalid/etc
debounce_score: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)  # 0-100
debounce_reason: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
debounce_suggestion: Mapped[Optional[str]] = mapped_column(String, nullable=True)  # Did you mean
debounce_processing_error: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
debounce_validated_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
```

**Total:** 8 new fields

**Reuse Existing Retry Fields:** ‚úÖ Already have `retry_count`, `next_retry_at`, `last_retry_at`

### Migration

**File:** Create new Alembic migration

```python
# Migration: Add DeBounce validation fields to contacts

def upgrade():
    op.add_column('contacts', sa.Column('debounce_validation_status', sa.String(), nullable=True))
    op.add_column('contacts', sa.Column('debounce_processing_status', sa.String(), nullable=True))
    op.add_column('contacts', sa.Column('debounce_result', sa.String(), nullable=True))
    op.add_column('contacts', sa.Column('debounce_score', sa.Integer(), nullable=True))
    op.add_column('contacts', sa.Column('debounce_reason', sa.String(500), nullable=True))
    op.add_column('contacts', sa.Column('debounce_suggestion', sa.String(), nullable=True))
    op.add_column('contacts', sa.Column('debounce_processing_error', sa.String(500), nullable=True))
    op.add_column('contacts', sa.Column('debounce_validated_at', sa.DateTime(timezone=True), nullable=True))

def downgrade():
    op.drop_column('contacts', 'debounce_validated_at')
    op.drop_column('contacts', 'debounce_processing_error')
    op.drop_column('contacts', 'debounce_suggestion')
    op.drop_column('contacts', 'debounce_reason')
    op.drop_column('contacts', 'debounce_score')
    op.drop_column('contacts', 'debounce_result')
    op.drop_column('contacts', 'debounce_processing_status')
    op.drop_column('contacts', 'debounce_validation_status')
```

### New ENUM (Optional)

**File:** `src/models/enums.py`

```python
class EmailValidationResult(str, Enum):
    Valid = "valid"
    Invalid = "invalid"
    CatchAll = "catch-all"
    Unknown = "unknown"
    Disposable = "disposable"
```

**Note:** Can reuse `CRMSyncStatus` and `CRMProcessingStatus` for consistency.

---

## Phase 1: Core Service Implementation

### Step 1.1: Configuration

**File:** `src/config/settings.py`

```python
# ============================================================================
# DeBounce Email Validation (WO-017)
# ============================================================================

# API Authentication
DEBOUNCE_API_KEY: Optional[str] = None  # api-key format: db_xxxxxxxx
DEBOUNCE_API_BASE_URL: str = "https://api.debounce.io/v1"

# Validation Scheduler (WO-017 Phase 2)
DEBOUNCE_VALIDATION_SCHEDULER_INTERVAL_MINUTES: int = 5
DEBOUNCE_VALIDATION_SCHEDULER_BATCH_SIZE: int = 50  # Max 50 free tier, 100 paid
DEBOUNCE_VALIDATION_SCHEDULER_MAX_INSTANCES: int = 1

# Validation Retry Logic (WO-017 Phase 2)
DEBOUNCE_VALIDATION_MAX_RETRIES: int = 3
DEBOUNCE_VALIDATION_RETRY_DELAY_MINUTES: int = 5
DEBOUNCE_VALIDATION_RETRY_EXPONENTIAL: bool = True

# Auto-CRM Queue Settings
DEBOUNCE_AUTO_QUEUE_VALID_EMAILS: bool = True  # Auto-queue valid emails for CRM
DEBOUNCE_AUTO_QUEUE_DEFAULT_CRM: str = "brevo"  # Which CRM to queue to
DEBOUNCE_SKIP_DISPOSABLE: bool = True  # Never queue disposable emails
DEBOUNCE_SKIP_INVALID: bool = True  # Never queue invalid emails
DEBOUNCE_QUEUE_CATCH_ALL: bool = False  # Don't auto-queue catch-all (manual review)
```

**File:** `.env.example`

```bash
# ============================================================================
# DeBounce Email Validation (WO-017)
# ============================================================================

# DeBounce API Configuration
DEBOUNCE_API_KEY=db_xxxxxxxxxxxxxxxxxxxxxxxx
DEBOUNCE_API_BASE_URL=https://api.debounce.io/v1

# DeBounce Validation Scheduler Settings
DEBOUNCE_VALIDATION_SCHEDULER_INTERVAL_MINUTES=5
DEBOUNCE_VALIDATION_SCHEDULER_BATCH_SIZE=50  # Max 50 (free tier) or 100 (paid tier)
DEBOUNCE_VALIDATION_SCHEDULER_MAX_INSTANCES=1

# DeBounce Retry Logic Settings
DEBOUNCE_VALIDATION_MAX_RETRIES=3
DEBOUNCE_VALIDATION_RETRY_DELAY_MINUTES=5
DEBOUNCE_VALIDATION_RETRY_EXPONENTIAL=true

# Auto-CRM Queue Settings (optional)
DEBOUNCE_AUTO_QUEUE_VALID_EMAILS=true   # Automatically queue validated emails for CRM sync
DEBOUNCE_AUTO_QUEUE_DEFAULT_CRM=brevo   # Default CRM to queue to (brevo, hubspot, mautic, n8n)
DEBOUNCE_SKIP_DISPOSABLE=true           # Never queue disposable emails for CRM
DEBOUNCE_SKIP_INVALID=true              # Never queue invalid emails for CRM
DEBOUNCE_QUEUE_CATCH_ALL=false          # Don't auto-queue catch-all emails (require manual review)
```

### Step 1.2: Core Service

**File:** `src/services/email_validation/debounce_service.py`

```python
"""
DeBounce Email Validation Service (WO-017 Phase 1)

Validates email addresses using DeBounce.io API before CRM sync.

Key Features:
- Bulk validation (up to 50 emails per request)
- Pre-CRM quality gate
- Auto-queue valid emails for CRM sync (optional)
- Exponential backoff retry logic
- SDK-compatible signature: process_batch_validation(contact_ids, session)

Architecture Pattern: WO-015/WO-016 validated pattern
DeBounce API Docs: https://debounce.io/api-documentation/
"""

import logging
from typing import List
from uuid import UUID
from datetime import datetime, timedelta

import httpx
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus

logger = logging.getLogger(__name__)


class DeBounceValidationService:
    """
    Service for validating email addresses using DeBounce.io API.

    Bulk validation approach:
    1. Collect batch of contacts (up to 50)
    2. Extract emails
    3. Call DeBounce bulk API
    4. Update all contacts with results
    5. Optionally auto-queue valid emails for CRM sync
    """

    def __init__(self):
        self.api_key = settings.DEBOUNCE_API_KEY
        self.base_url = settings.DEBOUNCE_API_BASE_URL
        self.batch_size = settings.DEBOUNCE_VALIDATION_SCHEDULER_BATCH_SIZE

    async def process_batch_validation(
        self, contact_ids: List[UUID], session: AsyncSession
    ) -> None:
        """
        Process a batch of contacts for email validation.

        SDK-compatible method signature for scheduler integration.

        Args:
            contact_ids: List of contact UUIDs to validate
            session: Async database session

        Raises:
            Exception: Re-raises all exceptions for SDK error handling
        """
        logger.info(f"üöÄ Starting DeBounce validation for {len(contact_ids)} contacts")

        # Fetch all contacts in batch
        stmt = select(Contact).where(Contact.id.in_(contact_ids))
        result = await session.execute(stmt)
        contacts = result.scalars().all()

        if not contacts:
            logger.error("‚ùå No contacts found - skipping")
            return

        try:
            await self._validate_contact_batch(contacts, session)
        except Exception as e:
            logger.exception(f"‚ùå Failed to validate batch: {e}")
            raise  # Re-raise for SDK to handle

    async def _validate_contact_batch(
        self, contacts: List[Contact], session: AsyncSession
    ) -> None:
        """
        Core business logic to validate a batch of contacts.

        Flow:
        1. Mark all as Processing
        2. Extract emails
        3. Call DeBounce bulk API
        4. Map results back to contacts
        5. Update statuses and optionally queue for CRM
        """
        try:
            # Step 1: Mark all as Processing
            for contact in contacts:
                contact.debounce_validation_status = "Processing"
                contact.debounce_processing_status = "Processing"
            await session.commit()

            # Step 2: Extract emails (skip contacts without email)
            email_to_contact = {}
            emails = []
            for contact in contacts:
                if contact.email:
                    email_to_contact[contact.email] = contact
                    emails.append(contact.email)
                else:
                    # No email - mark as error
                    contact.debounce_validation_status = "Error"
                    contact.debounce_processing_status = "Error"
                    contact.debounce_processing_error = "No email address"

            if not emails:
                logger.warning("No valid emails in batch")
                await session.commit()
                return

            logger.info(f"üìß Validating {len(emails)} emails via DeBounce API")

            # Step 3: Call DeBounce bulk API
            results = await self._call_debounce_bulk_api(emails)

            # Step 4: Map results back to contacts
            for result in results:
                email = result["email"]
                contact = email_to_contact.get(email)
                if not contact:
                    continue

                # Update validation fields
                contact.debounce_result = result["result"]
                contact.debounce_score = result.get("score", 0)
                contact.debounce_reason = result.get("reason", "")[:500]
                contact.debounce_suggestion = result.get("did_you_mean", "")
                contact.debounce_validated_at = datetime.utcnow()

                # Status: Complete
                contact.debounce_validation_status = "Complete"
                contact.debounce_processing_status = "Complete"
                contact.debounce_processing_error = None
                contact.retry_count = 0
                contact.next_retry_at = None

                logger.info(
                    f"‚úÖ Validated {email}: {result['result']} (score: {result.get('score', 0)})"
                )

                # Step 5: Auto-queue for CRM if valid (optional)
                if settings.DEBOUNCE_AUTO_QUEUE_VALID_EMAILS:
                    await self._auto_queue_for_crm(contact, result)

            await session.commit()
            logger.info(f"‚úÖ Batch validation complete: {len(results)} emails processed")

        except Exception as e:
            # Error handling with retry logic
            error_msg = str(e)
            logger.error(f"‚ùå Batch validation failed: {error_msg}")

            for contact in contacts:
                should_retry = contact.retry_count < settings.DEBOUNCE_VALIDATION_MAX_RETRIES

                if should_retry:
                    delay_minutes = self._calculate_retry_delay(contact.retry_count)
                    next_retry = datetime.utcnow() + timedelta(minutes=delay_minutes)

                    contact.debounce_validation_status = "Queued"
                    contact.debounce_processing_status = "Error"
                    contact.debounce_processing_error = error_msg[:500]
                    contact.retry_count += 1
                    contact.next_retry_at = next_retry
                else:
                    contact.debounce_validation_status = "Error"
                    contact.debounce_processing_status = "Error"

            await session.commit()
            raise

    async def _call_debounce_bulk_api(self, emails: List[str]) -> List[dict]:
        """
        Call DeBounce.io bulk validation API.

        Args:
            emails: List of email addresses to validate

        Returns:
            List of validation results

        Raises:
            httpx.HTTPStatusError: If API call fails
        """
        headers = {
            "Authorization": f"api-key {self.api_key}",
            "Content-Type": "application/json",
        }

        payload = {"emails": emails}

        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{self.base_url}/validate/bulk",
                headers=headers,
                json=payload,
            )

            if response.status_code != 200:
                logger.error(
                    f"DeBounce API failed (HTTP {response.status_code}): {response.text}"
                )
                response.raise_for_status()

            data = response.json()
            return data.get("results", [])

    async def _auto_queue_for_crm(self, contact: Contact, validation_result: dict):
        """
        Optionally auto-queue validated emails for CRM sync.

        Rules:
        - If result = 'valid' ‚Üí Queue for CRM
        - If result = 'disposable' and SKIP_DISPOSABLE ‚Üí Don't queue
        - If result = 'invalid' and SKIP_INVALID ‚Üí Don't queue
        - If result = 'catch-all' and !QUEUE_CATCH_ALL ‚Üí Don't queue

        Args:
            contact: Contact instance
            validation_result: DeBounce validation result
        """
        result = validation_result["result"]

        # Skip disposable if configured
        if result == "disposable" and settings.DEBOUNCE_SKIP_DISPOSABLE:
            logger.info(f"‚è≠Ô∏è Skipping disposable email: {contact.email}")
            return

        # Skip invalid if configured
        if result == "invalid" and settings.DEBOUNCE_SKIP_INVALID:
            logger.info(f"‚è≠Ô∏è Skipping invalid email: {contact.email}")
            return

        # Skip catch-all if configured
        if result == "catch-all" and not settings.DEBOUNCE_QUEUE_CATCH_ALL:
            logger.info(f"‚è≠Ô∏è Skipping catch-all email (manual review): {contact.email}")
            return

        # Queue for CRM if valid
        if result == "valid":
            crm = settings.DEBOUNCE_AUTO_QUEUE_DEFAULT_CRM
            logger.info(f"üì§ Auto-queueing {contact.email} for {crm} sync")

            # Set CRM status dynamically
            setattr(contact, f"{crm}_sync_status", CRMSyncStatus.Queued.value)
            setattr(contact, f"{crm}_processing_status", CRMProcessingStatus.Queued.value)

    def _calculate_retry_delay(self, retry_count: int) -> int:
        """
        Calculate retry delay in minutes with exponential backoff.

        Args:
            retry_count: Current retry attempt (0-indexed)

        Returns:
            Delay in minutes
        """
        base_delay = settings.DEBOUNCE_VALIDATION_RETRY_DELAY_MINUTES

        if settings.DEBOUNCE_VALIDATION_RETRY_EXPONENTIAL:
            return base_delay * (2**retry_count)
        else:
            return base_delay * (retry_count + 1)
```

**Estimated Lines:** ~350

### Step 1.3: Manual Test Script

**File:** `test_manual_debounce.py`

```python
#!/usr/bin/env python3
"""Manual test script for DeBounce validation service."""

import asyncio
import sys
from uuid import UUID
from src.services.email_validation.debounce_service import DeBounceValidationService
from src.session.async_session import get_db_session
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def test_manual_validation(contact_ids: list):
    """Manually validate contacts."""
    contact_uuids = [UUID(id) for id in contact_ids]
    service = DeBounceValidationService()

    if not service.api_key:
        logger.error("‚ùå DEBOUNCE_API_KEY not configured in .env!")
        return False

    async for session in get_db_session():
        try:
            await service.process_batch_validation(contact_uuids, session)
            logger.info("‚úÖ VALIDATION COMPLETED SUCCESSFULLY!")
            return True
        except Exception as e:
            logger.exception(f"‚ùå VALIDATION FAILED: {e}")
            return False


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python test_manual_debounce.py <contact_id> [<contact_id2> ...]")
        sys.exit(1)

    contact_ids = sys.argv[1:]
    success = asyncio.run(test_manual_validation(contact_ids))
    sys.exit(0 if success else 1)
```

---

## Phase 2: Scheduler Implementation

**File:** `src/services/email_validation/debounce_scheduler.py`

```python
"""
DeBounce Validation Scheduler (WO-017 Phase 2)

Background scheduler that automatically validates contacts queued for email validation.

Architecture: SDK-compatible scheduler using run_job_loop pattern.
Pattern Reference: src/services/crm/brevo_sync_scheduler.py
"""

import logging
from datetime import datetime
from sqlalchemy import asc, or_

from src.common.curation_sdk.scheduler_loop import run_job_loop
from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMProcessingStatus

from .debounce_service import DeBounceValidationService

logger = logging.getLogger(__name__)


async def process_debounce_validation_queue():
    """
    Processes contacts queued for email validation using SDK job loop.

    Batch processing approach:
    1. Fetch 50 contacts with debounce_processing_status = 'Queued'
    2. Process as bulk via DeBounce API
    3. Update all with results
    """
    service = DeBounceValidationService()
    logger.info("üöÄ Starting DeBounce validation scheduler cycle")

    await run_job_loop(
        model=Contact,
        status_enum=CRMProcessingStatus,
        queued_status=CRMProcessingStatus.Queued,
        processing_status=CRMProcessingStatus.Processing,
        completed_status=CRMProcessingStatus.Complete,
        failed_status=CRMProcessingStatus.Error,
        processing_function=service.process_batch_validation,
        batch_size=settings.DEBOUNCE_VALIDATION_SCHEDULER_BATCH_SIZE,
        order_by_column=asc(Contact.updated_at),
        status_field_name="debounce_processing_status",
        error_field_name="debounce_processing_error",
        additional_filters=[
            or_(
                Contact.next_retry_at.is_(None),
                Contact.next_retry_at <= datetime.utcnow(),
            )
        ],
    )

    logger.info("‚úÖ Finished DeBounce validation scheduler cycle")


from src.scheduler_instance import scheduler


def setup_debounce_validation_scheduler():
    """Registers DeBounce validation scheduler with APScheduler."""
    if not settings.DEBOUNCE_API_KEY:
        logger.warning(
            "‚ö†Ô∏è DEBOUNCE_API_KEY not configured - Email validation scheduler DISABLED"
        )
        return

    logger.info("üìã Configuring DeBounce validation scheduler...")
    logger.info(
        f"   Interval: {settings.DEBOUNCE_VALIDATION_SCHEDULER_INTERVAL_MINUTES} minutes"
    )
    logger.info(
        f"   Batch size: {settings.DEBOUNCE_VALIDATION_SCHEDULER_BATCH_SIZE} emails"
    )

    scheduler.add_job(
        process_debounce_validation_queue,
        trigger="interval",
        minutes=settings.DEBOUNCE_VALIDATION_SCHEDULER_INTERVAL_MINUTES,
        id="debounce_email_validation_processor",
        name="DeBounce Email Validation Processor",
        replace_existing=True,
        max_instances=settings.DEBOUNCE_VALIDATION_SCHEDULER_MAX_INSTANCES,
        misfire_grace_time=1800,
    )

    logger.info("‚úÖ DeBounce validation scheduler job registered successfully")
```

**Register in main.py:**
```python
from src.services.email_validation.debounce_scheduler import setup_debounce_validation_scheduler

# In lifespan:
try:
    setup_debounce_validation_scheduler()
except Exception as e:
    logger.error(f"Failed to setup DeBounce validation scheduler: {e}", exc_info=True)
```

---

## Phase 3: API Endpoints (NEW!)

**This addresses the CRM sync gap identified in strategic analysis.**

**File:** `src/routers/v3/email_validation_router.py`

```python
"""
Email Validation API Endpoints (WO-017 Phase 3)

Provides user-facing API for queueing contacts for email validation.
"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from uuid import UUID
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession

from src.session.async_session import get_db_session
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus

router = APIRouter(prefix="/api/v3/email-validation", tags=["Email Validation"])


class QueueValidationRequest(BaseModel):
    auto_queue_crm: bool = True  # Auto-queue for CRM if valid
    crm: str = "brevo"  # Default CRM to queue to


@router.post("/contacts/{contact_id}/queue")
async def queue_contact_for_validation(
    contact_id: UUID,
    request: QueueValidationRequest,
    session: AsyncSession = Depends(get_db_session),
):
    """Queue a single contact for email validation."""
    contact = await session.get(Contact, contact_id)
    if not contact:
        raise HTTPException(404, "Contact not found")
    if not contact.email:
        raise HTTPException(400, "Contact has no email address")

    contact.debounce_validation_status = "Queued"
    contact.debounce_processing_status = "Queued"
    contact.retry_count = 0
    contact.next_retry_at = None

    await session.commit()

    return {
        "contact_id": str(contact_id),
        "email": contact.email,
        "validation_status": "Queued",
        "estimated_processing": "Within 5 minutes",
    }


@router.post("/contacts/bulk-queue")
async def bulk_queue_validation(
    contact_ids: List[UUID], session: AsyncSession = Depends(get_db_session)
):
    """Queue multiple contacts for email validation."""
    # Bulk update logic
    pass


@router.get("/contacts/{contact_id}/status")
async def get_validation_status(
    contact_id: UUID, session: AsyncSession = Depends(get_db_session)
):
    """Get email validation status for a contact."""
    contact = await session.get(Contact, contact_id)
    if not contact:
        raise HTTPException(404, "Contact not found")

    return {
        "contact_id": str(contact_id),
        "email": contact.email,
        "validation_status": contact.debounce_validation_status,
        "processing_status": contact.debounce_processing_status,
        "result": contact.debounce_result,
        "score": contact.debounce_score,
        "reason": contact.debounce_reason,
        "suggestion": contact.debounce_suggestion,
        "validated_at": contact.debounce_validated_at,
    }
```

**Register in main.py:**
```python
from .routers.v3.email_validation_router import router as email_validation_router

app.include_router(email_validation_router)
```

---

## Configuration Summary

**Required:**
- `DEBOUNCE_API_KEY` - From DeBounce.io dashboard

**Optional:**
- Scheduler interval/batch size
- Retry logic settings
- Auto-CRM queue settings

---

## Testing Strategy

**Phase 1 Test:** Manual validation script
**Phase 2 Test:** Scheduler integration in Docker
**Phase 3 Test:** API endpoint validation

**Test Plan:** Create `WO-017.2_DEBOUNCE_INTEGRATION_TEST_PLAN.md`

---

## Success Criteria

- [ ] Database migration adds 8 validation fields
- [ ] Core service validates emails via DeBounce API
- [ ] Scheduler processes batches of 50 emails automatically
- [ ] API endpoints allow queueing contacts for validation
- [ ] Valid emails auto-queue for CRM sync (if configured)
- [ ] Disposable/invalid emails skip CRM sync
- [ ] Retry logic works with exponential backoff
- [ ] Integration test plan passes

---

## Timeline Estimate

| Phase | Duration |
|-------|----------|
| Database Migration | 30 min |
| Phase 1: Core Service | 2-3 hours |
| Phase 2: Scheduler | 1 hour |
| Phase 3: API Endpoints | 2 hours |
| Testing & Documentation | 1-2 hours |
| **TOTAL** | **6-8 hours** |

---

## Related Work Orders

- **WO-015:** Brevo Integration (pattern reference)
- **WO-016:** HubSpot Integration (pattern reference)
- **WO-018:** CRM API Endpoints (complementary)

---

**END OF IMPLEMENTATION PLAN**
