# WO-015.4: Brevo Multi-CRM Implementation Plan - PHASED APPROACH

**Created:** 2025-01-18
**Status:** Draft - Awaiting Local Claude Review
**Priority:** P1 (High Priority)
**Strategy:** Conservative, phased rollout with testing gates

---

## Executive Summary

This document outlines a **safe, phased implementation** strategy for multi-CRM sync functionality. The approach prioritizes:

1. âœ… **No Breaking Changes** - All existing functionality continues to work
2. âœ… **Test Before Proceed** - Each phase has testing gate before next phase
3. âœ… **Incremental Value** - Each phase delivers working functionality
4. âœ… **Easy Rollback** - Each phase can be independently reverted

**Total Phases:** 4
**Estimated Duration:** 12-15 days (2.5-3 weeks)
**Testing Gates:** 4 (one per phase)

---

## Implementation Philosophy

### Conservative Approach
- **Phase 1:** Selection endpoints only (no sync services yet)
- **Phase 2:** Single CRM sync (Brevo) - prove the pattern works
- **Phase 3:** Scale pattern to remaining CRMs (HubSpot fix, n8n, Mautic)
- **Phase 4:** Advanced features (retry logic, monitoring, webhooks)

### Testing Gates
Each phase MUST pass testing before proceeding to next phase:
- âœ… Unit tests pass
- âœ… Integration tests pass
- âœ… Manual testing checklist completed
- âœ… Code review by local Claude
- âœ… User acceptance test (UAT)

---

## Phase 1: CRM Selection Endpoints (Days 1-3)

**Goal:** Add endpoints to mark contacts for CRM sync (all 4 CRMs)
**Risk Level:** ðŸŸ¢ Low (read/write only, no external API calls)
**Deliverable:** Working endpoints to set `{crm}_sync_status = 'Selected'`

### 1.1 Update Existing Contacts Router

**File:** `src/routers/v3/contacts_router.py`

**Changes Required:**

#### A. Add CRM Status Filters to List Endpoint
**Location:** Line 109 (add to query parameters)

```python
@router.get("", response_model=List[ContactRead])
async def list_contacts(
    session: AsyncSession = Depends(get_db_session),
    current_user: Dict[str, Any] = Depends(get_current_user),
    limit: int = Query(100, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    contact_curation_status: Optional[ContactCurationStatus] = Query(None),
    contact_processing_status: Optional[ContactProcessingStatus] = Query(None),
    hubspot_sync_status: Optional[HubSpotSyncStatus] = Query(None),
    brevo_sync_status: Optional[CRMSyncStatus] = Query(None),      # ADD
    mautic_sync_status: Optional[CRMSyncStatus] = Query(None),     # ADD
    n8n_sync_status: Optional[CRMSyncStatus] = Query(None),        # ADD
    email_type: Optional[ContactEmailTypeEnum] = Query(None),
    # ... rest of parameters
):
    """Retrieve a list of contacts with filtering and pagination."""
    filters = []
    # ... existing filters ...

    # ADD these filter blocks
    if brevo_sync_status:
        filters.append(Contact.brevo_sync_status == brevo_sync_status.value)
    if mautic_sync_status:
        filters.append(Contact.mautic_sync_status == mautic_sync_status.value)
    if n8n_sync_status:
        filters.append(Contact.n8n_sync_status == n8n_sync_status.value)

    # ... rest of function unchanged
```

**Why:** Allows frontend to filter contacts by CRM sync status

---

#### B. Add Multi-CRM Selection Endpoint (NEW)
**Location:** After line 227 (after existing batch update endpoints)

```python
@router.put("/crm/select", response_model=Dict[str, Any])
async def select_contacts_for_crm_sync(
    request: CRMSelectionRequest,
    session: AsyncSession = Depends(get_db_session),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Mark contacts as 'Selected' for one or more CRM platforms.

    Sets {crm}_sync_status = 'Selected' for specified CRMs.
    Does NOT queue for processing yet - that happens when sync service is implemented.

    Request body:
    {
        "contact_ids": ["uuid1", "uuid2"],
        "crms": ["brevo", "hubspot"],  // Which CRMs to mark as selected
        "action": "select"  // or "unselect" to set back to "New"
    }
    """
    if not request.contact_ids:
        return {
            "updated_count": 0,
            "message": "No contact IDs provided"
        }

    if not request.crms:
        return {
            "updated_count": 0,
            "message": "No CRMs specified"
        }

    # Validate CRM names
    valid_crms = {"brevo", "mautic", "n8n", "hubspot"}
    invalid_crms = set(request.crms) - valid_crms
    if invalid_crms:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid CRM names: {invalid_crms}. Valid: {valid_crms}"
        )

    stmt = select(Contact).where(Contact.id.in_(request.contact_ids))
    result = await session.execute(stmt)
    contacts = result.scalars().all()

    if not contacts:
        raise HTTPException(
            status_code=404,
            detail="No contacts found with provided IDs"
        )

    updated_count = 0
    target_status = CRMSyncStatus.Selected.value if request.action == "select" else CRMSyncStatus.New.value

    for contact in contacts:
        for crm in request.crms:
            # Update the appropriate status field
            if crm == "brevo":
                contact.brevo_sync_status = target_status
            elif crm == "mautic":
                contact.mautic_sync_status = target_status
            elif crm == "n8n":
                contact.n8n_sync_status = target_status
            elif crm == "hubspot":
                contact.hubspot_sync_status = target_status

        updated_count += 1

    await session.commit()

    return {
        "updated_count": updated_count,
        "crms": request.crms,
        "action": request.action,
        "message": f"{request.action.capitalize()}ed {updated_count} contacts for {len(request.crms)} CRM(s)"
    }
```

**Why:**
- Single endpoint handles all 4 CRMs (reduces code duplication)
- Can select for multiple CRMs simultaneously
- Can unselect if user changes mind
- Follows existing batch update pattern

---

### 1.2 Add New Schema Definitions

**File:** `src/schemas/contact_schemas.py`

**Add after existing schemas:**

```python
class CRMSelectionRequest(BaseModel):
    """Request to mark contacts for CRM sync"""
    contact_ids: List[uuid.UUID]
    crms: List[str]  # ["brevo", "hubspot", "mautic", "n8n"]
    action: str = "select"  # "select" or "unselect"

    model_config = ConfigDict(from_attributes=True)

    @field_validator('action')
    @classmethod
    def validate_action(cls, v):
        if v not in ["select", "unselect"]:
            raise ValueError("action must be 'select' or 'unselect'")
        return v

    @field_validator('crms')
    @classmethod
    def validate_crms(cls, v):
        valid_crms = {"brevo", "mautic", "n8n", "hubspot"}
        invalid = set(v) - valid_crms
        if invalid:
            raise ValueError(f"Invalid CRM names: {invalid}")
        return v
```

**Why:**
- Type-safe request validation
- Prevents invalid CRM names
- Validates action is select/unselect

---

### 1.3 Update Router Imports

**File:** `src/routers/v3/contacts_router.py`

**Add to imports (line 11-17):**

```python
from src.models.enums import (
    ContactCurationStatus,
    ContactEmailTypeEnum,
    ContactProcessingStatus,
    HubSpotProcessingStatus,
    HubSpotSyncStatus,
    CRMSyncStatus,        # ADD
    CRMProcessingStatus,  # ADD
)
from src.schemas.contact_schemas import (
    ContactCreate,
    ContactCurationBatchStatusUpdateRequest,
    ContactCurationBatchUpdateResponse,
    ContactCurationFilteredUpdateRequest,
    ContactRead,
    ContactUpdate,
    CRMSelectionRequest,  # ADD
)
```

---

### 1.4 Phase 1 Testing Checklist

#### Unit Tests
**File:** `tests/routers/test_contacts_router_phase1.py` (NEW FILE)

```python
"""
Phase 1 Tests: CRM Selection Endpoints
"""

import pytest
from httpx import AsyncClient
from src.main import app


@pytest.mark.asyncio
async def test_select_contacts_for_brevo(test_db, auth_headers, test_contacts):
    """Test selecting contacts for Brevo sync"""
    contact_ids = [str(test_contacts[0].id), str(test_contacts[1].id)]

    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.put(
            "/api/v3/contacts/crm/select",
            json={
                "contact_ids": contact_ids,
                "crms": ["brevo"],
                "action": "select"
            },
            headers=auth_headers,
        )

    assert response.status_code == 200
    data = response.json()
    assert data["updated_count"] == 2
    assert "brevo" in data["crms"]

    # Verify database state
    # ... check brevo_sync_status = 'Selected'


@pytest.mark.asyncio
async def test_select_contacts_for_multiple_crms(test_db, auth_headers, test_contacts):
    """Test selecting contacts for multiple CRMs simultaneously"""
    contact_ids = [str(test_contacts[0].id)]

    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.put(
            "/api/v3/contacts/crm/select",
            json={
                "contact_ids": contact_ids,
                "crms": ["brevo", "hubspot", "mautic"],
                "action": "select"
            },
            headers=auth_headers,
        )

    assert response.status_code == 200
    data = response.json()
    assert data["updated_count"] == 1
    assert len(data["crms"]) == 3


@pytest.mark.asyncio
async def test_unselect_contacts(test_db, auth_headers, test_contacts):
    """Test unselecting contacts (revert to 'New' status)"""
    # First select
    # Then unselect
    # Verify status back to 'New'


@pytest.mark.asyncio
async def test_filter_contacts_by_crm_status(test_db, auth_headers, test_contacts):
    """Test filtering contacts by CRM sync status"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get(
            "/api/v3/contacts?brevo_sync_status=Selected",
            headers=auth_headers,
        )

    assert response.status_code == 200
    # Verify filtered results


@pytest.mark.asyncio
async def test_invalid_crm_name(test_db, auth_headers, test_contacts):
    """Test error handling for invalid CRM name"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.put(
            "/api/v3/contacts/crm/select",
            json={
                "contact_ids": [str(test_contacts[0].id)],
                "crms": ["invalid_crm"],
                "action": "select"
            },
            headers=auth_headers,
        )

    assert response.status_code == 400
    assert "Invalid CRM names" in response.json()["detail"]
```

**Run tests:**
```bash
pytest tests/routers/test_contacts_router_phase1.py -v
```

---

#### Manual Testing

**Prerequisites:**
- [ ] Application running locally or deployed
- [ ] JWT token available
- [ ] Test contacts exist in database

**Test Steps:**

1. **Select contacts for Brevo:**
   ```bash
   curl -X PUT http://localhost:8000/api/v3/contacts/crm/select \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "contact_ids": ["<uuid1>", "<uuid2>"],
       "crms": ["brevo"],
       "action": "select"
     }'
   ```

   Expected: `{"updated_count": 2, "crms": ["brevo"], ...}`

2. **Verify database state:**
   ```sql
   SELECT id, email, brevo_sync_status, brevo_processing_status
   FROM contacts
   WHERE brevo_sync_status = 'Selected';
   ```

   Expected: 2 contacts with `brevo_sync_status = 'Selected'`, `brevo_processing_status = NULL`

3. **Select same contacts for multiple CRMs:**
   ```bash
   curl -X PUT http://localhost:8000/api/v3/contacts/crm/select \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "contact_ids": ["<uuid1>"],
       "crms": ["brevo", "hubspot", "mautic"],
       "action": "select"
     }'
   ```

   Expected: All 3 CRM status fields = 'Selected'

4. **Filter contacts by CRM status:**
   ```bash
   curl http://localhost:8000/api/v3/contacts?brevo_sync_status=Selected \
     -H "Authorization: Bearer $JWT_TOKEN"
   ```

   Expected: List of contacts with Brevo status = 'Selected'

5. **Unselect contacts:**
   ```bash
   curl -X PUT http://localhost:8000/api/v3/contacts/crm/select \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "contact_ids": ["<uuid1>"],
       "crms": ["brevo"],
       "action": "unselect"
     }'
   ```

   Expected: `brevo_sync_status` back to 'New'

6. **Test invalid CRM name:**
   ```bash
   curl -X PUT http://localhost:8000/api/v3/contacts/crm/select \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "contact_ids": ["<uuid1>"],
       "crms": ["invalid"],
       "action": "select"
     }'
   ```

   Expected: 400 error with message about invalid CRM

---

### 1.5 Phase 1 Testing Gate

**Phase 1 is COMPLETE when:**
- [x] All unit tests pass
- [x] All manual tests pass
- [x] No existing functionality broken (contacts CRUD still works)
- [x] Code reviewed by local Claude
- [x] User can select/unselect contacts for all 4 CRMs via API
- [x] User tested and approved

**DO NOT PROCEED to Phase 2 until all checkboxes above are checked.**

---

### 1.6 Phase 1 Rollback Plan

If Phase 1 needs to be rolled back:

1. **Revert code changes:**
   ```bash
   git revert <phase-1-commit-hash>
   git push
   ```

2. **No database rollback needed** - Phase 1 only reads/writes existing fields

3. **Verify rollback:**
   - Existing contact endpoints still work
   - No API errors

---

## Phase 2: Brevo Sync Service (Days 4-8)

**Goal:** Implement complete Brevo sync (service + scheduler + retry)
**Risk Level:** ðŸŸ¡ Medium (external API calls to Brevo)
**Deliverable:** Contacts marked 'Selected' for Brevo automatically sync

### 2.1 Configuration

**File:** `src/config/settings.py`

**Add Brevo configuration:**

```python
class Settings(BaseSettings):
    # ... existing settings ...

    # Brevo CRM Integration
    BREVO_API_KEY: Optional[str] = None
    BREVO_LIST_ID: Optional[str] = None  # Optional
    BREVO_API_BASE_URL: str = "https://api.brevo.com/v3"

    # Brevo Sync Scheduler
    BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES: int = 5
    BREVO_SYNC_SCHEDULER_BATCH_SIZE: int = 10
    BREVO_SYNC_SCHEDULER_MAX_INSTANCES: int = 1

    # Brevo Retry Logic
    BREVO_SYNC_MAX_RETRIES: int = 3
    BREVO_SYNC_RETRY_DELAY_MINUTES: int = 5
    BREVO_SYNC_RETRY_EXPONENTIAL: bool = True
```

**Environment Variables (.env.example):**

```bash
# Brevo CRM Integration
BREVO_API_KEY=your_brevo_api_key_here
BREVO_LIST_ID=  # Optional - leave empty if no list

# Brevo Sync Scheduler
BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES=5
BREVO_SYNC_SCHEDULER_BATCH_SIZE=10
BREVO_SYNC_SCHEDULER_MAX_INSTANCES=1

# Brevo Retry Logic
BREVO_SYNC_MAX_RETRIES=3
BREVO_SYNC_RETRY_DELAY_MINUTES=5
BREVO_SYNC_RETRY_EXPONENTIAL=true
```

---

### 2.2 Brevo Sync Service

**File:** `src/services/brevo_sync_service.py` (NEW FILE)

```python
"""
Brevo Contact Sync Service
Handles synchronization of contacts to Brevo CRM via their API
"""

import logging
from typing import Optional
from datetime import datetime, timedelta
import httpx
from sqlalchemy.ext.asyncio import AsyncSession

from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus

logger = logging.getLogger(__name__)


class BrevoSyncService:
    """Service for syncing contacts to Brevo CRM"""

    def __init__(self):
        self.api_key = settings.BREVO_API_KEY
        self.list_id = settings.BREVO_LIST_ID
        self.base_url = settings.BREVO_API_BASE_URL

        if not self.api_key:
            logger.warning("BREVO_API_KEY not configured - Brevo sync will fail")

    async def process_single_contact(
        self,
        contact: Contact,
        session: AsyncSession
    ) -> None:
        """
        Process a single contact for Brevo sync.

        Called by scheduler via SDK job loop pattern.
        Updates contact.brevo_sync_status based on result.

        Args:
            contact: Contact model instance
            session: Async database session (managed by SDK)
        """
        logger.info(f"Processing Brevo sync for contact {contact.id} ({contact.email})")

        try:
            # Validate contact has email
            if not contact.email:
                raise ValueError("Contact has no email address")

            # Update to processing state
            contact.brevo_sync_status = CRMSyncStatus.Processing.value
            contact.brevo_processing_status = CRMProcessingStatus.Processing.value
            await session.commit()  # Commit status change immediately for visibility

            # Call Brevo API
            brevo_contact_id = await self._sync_to_brevo_api(contact)

            # Update to complete state
            contact.brevo_sync_status = CRMSyncStatus.Complete.value
            contact.brevo_processing_status = CRMProcessingStatus.Complete.value
            contact.brevo_processing_error = None
            contact.brevo_contact_id = brevo_contact_id
            contact.retry_count = 0  # Reset retry count on success
            contact.next_retry_at = None
            contact.last_failed_crm = None

            logger.info(f"Successfully synced contact {contact.id} to Brevo")

        except Exception as e:
            error_msg = str(e)
            logger.exception(f"Failed to sync contact {contact.id} to Brevo: {error_msg}")

            # Check if we should retry
            should_retry = contact.retry_count < settings.BREVO_SYNC_MAX_RETRIES

            if should_retry:
                # Calculate next retry time with exponential backoff
                delay_minutes = self._calculate_retry_delay(contact.retry_count)
                next_retry = datetime.utcnow() + timedelta(minutes=delay_minutes)

                # Update for retry
                contact.brevo_sync_status = CRMSyncStatus.Queued.value  # Stay queued
                contact.brevo_processing_status = CRMProcessingStatus.Error.value
                contact.brevo_processing_error = error_msg[:500]
                contact.retry_count += 1
                contact.last_retry_at = datetime.utcnow()
                contact.next_retry_at = next_retry
                contact.last_failed_crm = "brevo"

                logger.info(
                    f"Scheduled retry {contact.retry_count}/{settings.BREVO_SYNC_MAX_RETRIES} "
                    f"for contact {contact.id} at {next_retry}"
                )
            else:
                # Max retries exceeded - mark as error
                contact.brevo_sync_status = CRMSyncStatus.Error.value
                contact.brevo_processing_status = CRMProcessingStatus.Error.value
                contact.brevo_processing_error = f"Max retries exceeded. Last error: {error_msg[:400]}"
                contact.last_failed_crm = "brevo"

                logger.error(
                    f"Contact {contact.id} failed after {contact.retry_count} retries. "
                    f"Marked as Error."
                )

            # Don't re-raise - let SDK handle transaction commit

    def _calculate_retry_delay(self, retry_count: int) -> int:
        """
        Calculate retry delay with exponential backoff.

        Args:
            retry_count: Number of retries so far

        Returns:
            Delay in minutes
        """
        base_delay = settings.BREVO_SYNC_RETRY_DELAY_MINUTES

        if settings.BREVO_SYNC_RETRY_EXPONENTIAL:
            # Exponential backoff: base * 2^(retry_count)
            return base_delay * (2 ** retry_count)
        else:
            # Linear backoff: base * (retry_count + 1)
            return base_delay * (retry_count + 1)

    async def _sync_to_brevo_api(self, contact: Contact) -> Optional[str]:
        """
        Sync contact to Brevo via API.

        API Documentation: https://developers.brevo.com/reference/createcontact

        Returns:
            Brevo contact ID (email address) if successful

        Raises:
            httpx.HTTPError: If API request fails
            ValueError: If response is invalid
        """
        if not self.api_key:
            raise ValueError("BREVO_API_KEY not configured")

        headers = {
            "api-key": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        # Build Brevo contact payload
        payload = {
            "email": contact.email,
            "attributes": {},
            "updateEnabled": True,  # Update if contact already exists (idempotent)
        }

        # Add optional attributes
        if contact.name:
            # Try to split name into first/last
            name_parts = contact.name.strip().split(maxsplit=1)
            payload["attributes"]["FIRSTNAME"] = name_parts[0]
            if len(name_parts) > 1:
                payload["attributes"]["LASTNAME"] = name_parts[1]

        if contact.phone_number:
            payload["attributes"]["SMS"] = contact.phone_number

        # Add custom attributes (ScraperSky-specific)
        if contact.domain_id:
            payload["attributes"]["DOMAIN_ID"] = str(contact.domain_id)
        if contact.page_id:
            payload["attributes"]["PAGE_ID"] = str(contact.page_id)
        if contact.email_type:
            payload["attributes"]["EMAIL_TYPE"] = contact.email_type
        if contact.source_url:
            payload["attributes"]["SOURCE_URL"] = contact.source_url
        if contact.has_gmail is not None:
            payload["attributes"]["HAS_GMAIL"] = str(contact.has_gmail)

        # Add to list if configured
        if self.list_id:
            try:
                payload["listIds"] = [int(self.list_id)]
            except ValueError:
                logger.warning(f"Invalid BREVO_LIST_ID: {self.list_id} - syncing without list")

        logger.debug(f"Brevo API payload: {payload}")

        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{self.base_url}/contacts",
                headers=headers,
                json=payload,
            )

            # Brevo returns:
            # - 201 Created for new contact
            # - 204 No Content for updated contact
            if response.status_code in [201, 204]:
                # Brevo uses email as contact ID
                return contact.email

            # Handle errors
            if response.status_code == 400:
                # Bad request - likely invalid data
                error_detail = response.json().get("message", response.text)
                raise ValueError(f"Brevo API error: {error_detail}")

            # Other errors
            response.raise_for_status()

            # Shouldn't reach here but handle gracefully
            logger.warning(
                f"Unexpected Brevo API response: {response.status_code} - {response.text}"
            )
            return contact.email
```

**Key Features:**
- âœ… Exponential backoff retry logic
- âœ… Updates retry tracking fields
- âœ… Stores Brevo contact ID
- âœ… Handles all Brevo API error codes
- âœ… Idempotent (updateEnabled=true)
- âœ… Compatible with SDK job loop pattern

---

### 2.3 Brevo Sync Scheduler

**File:** `src/services/brevo_sync_scheduler.py` (NEW FILE)

```python
"""
Brevo Contact Sync Scheduler
Background scheduler that processes contacts selected for Brevo sync
"""

import logging
from datetime import datetime
from sqlalchemy import asc, and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from src.scheduler_instance import scheduler
from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus
from src.services.brevo_sync_service import BrevoSyncService
from src.common.curation_sdk.scheduler_loop import run_job_loop
from src.db.session import get_db_session

logger = logging.getLogger(__name__)


async def process_brevo_sync_queue():
    """
    Scheduler job: Process contacts queued for Brevo sync.

    Finds contacts where:
    - brevo_sync_status = 'Selected' OR 'Queued'
    - brevo_processing_status = NULL OR 'Queued'
    """
    logger.info("Starting Brevo sync scheduler cycle")

    try:
        service = BrevoSyncService()

        # Process contacts with brevo_processing_status = 'Queued'
        # OR brevo_sync_status = 'Selected' AND brevo_processing_status = NULL
        # This handles both manual selections and retries

        async for session in get_db_session():
            stmt = (
                select(Contact)
                .where(
                    and_(
                        Contact.brevo_sync_status.in_(['Selected', 'Queued']),
                        Contact.brevo_processing_status.in_([None, 'Queued']),
                        # Exclude contacts waiting for retry
                        (Contact.next_retry_at == None) | (Contact.next_retry_at <= datetime.utcnow())
                    )
                )
                .order_by(asc(Contact.updated_at))
                .limit(settings.BREVO_SYNC_SCHEDULER_BATCH_SIZE)
            )

            result = await session.execute(stmt)
            contacts = result.scalars().all()

            if not contacts:
                logger.info("No contacts queued for Brevo sync")
                return

            logger.info(f"Processing {len(contacts)} contacts for Brevo sync")

            for contact in contacts:
                # Update processing status before processing
                contact.brevo_processing_status = CRMProcessingStatus.Queued.value
                await session.commit()

                # Process contact
                await service.process_single_contact(contact, session)
                await session.commit()

    except Exception as e:
        logger.exception(f"Critical error in Brevo sync scheduler: {e}")
        # Don't re-raise - let scheduler continue on next interval

    logger.info("Finished Brevo sync scheduler cycle")


def setup_brevo_sync_scheduler():
    """
    Register Brevo sync scheduler with shared scheduler instance.

    Called from src/scheduler_manager.py during app startup.
    """
    job_id = "brevo_contact_sync_processor"

    if not settings.BREVO_API_KEY:
        logger.warning(
            "BREVO_API_KEY not configured - Brevo sync scheduler will be disabled"
        )
        return

    scheduler.add_job(
        process_brevo_sync_queue,
        trigger="interval",
        minutes=settings.BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES,
        id=job_id,
        name="Brevo Contact Sync Processor",
        replace_existing=True,
        max_instances=settings.BREVO_SYNC_SCHEDULER_MAX_INSTANCES,
        misfire_grace_time=1800,  # 30 minutes grace period
    )

    logger.info(
        f"âœ… Brevo sync scheduler registered "
        f"(interval: {settings.BREVO_SYNC_SCHEDULER_INTERVAL_MINUTES} min, "
        f"batch size: {settings.BREVO_SYNC_SCHEDULER_BATCH_SIZE})"
    )
```

**Why This Approach:**
- âœ… Processes contacts with status 'Selected' OR 'Queued'
- âœ… Respects retry timing (checks `next_retry_at`)
- âœ… Uses established scheduler pattern
- âœ… Gracefully disables if API key not configured

---

### 2.4 Register Scheduler at Startup

**File:** `src/scheduler_manager.py` or `src/main.py`

**Find the scheduler setup function and add:**

```python
from src.services.brevo_sync_scheduler import setup_brevo_sync_scheduler

def setup_schedulers():
    """Initialize all schedulers"""
    # ... existing schedulers ...

    # Brevo sync scheduler
    setup_brevo_sync_scheduler()

    logger.info("All schedulers initialized")
```

---

### 2.5 Phase 2 Testing Checklist

#### Unit Tests
**File:** `tests/services/test_brevo_sync_service.py` (NEW FILE)

```python
"""
Phase 2 Tests: Brevo Sync Service
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timedelta
from src.services.brevo_sync_service import BrevoSyncService
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus


@pytest.mark.asyncio
async def test_brevo_sync_success():
    """Test successful contact sync to Brevo"""
    service = BrevoSyncService()

    contact = Contact(
        id="test-uuid",
        email="test@example.com",
        name="Test User",
        phone_number="555-1234",
        brevo_sync_status="Selected",
        retry_count=0,
    )

    session = AsyncMock()

    with patch.object(service, '_sync_to_brevo_api', return_value="test@example.com"):
        await service.process_single_contact(contact, session)

    assert contact.brevo_sync_status == CRMSyncStatus.Complete.value
    assert contact.brevo_processing_status == CRMProcessingStatus.Complete.value
    assert contact.brevo_processing_error is None
    assert contact.brevo_contact_id == "test@example.com"
    assert contact.retry_count == 0


@pytest.mark.asyncio
async def test_brevo_sync_retry_logic():
    """Test retry logic with exponential backoff"""
    service = BrevoSyncService()

    contact = Contact(
        id="test-uuid",
        email="test@example.com",
        brevo_sync_status="Selected",
        retry_count=0,
    )

    session = AsyncMock()

    # Mock API failure
    with patch.object(service, '_sync_to_brevo_api', side_effect=Exception("API Error")):
        await service.process_single_contact(contact, session)

    # Should be queued for retry
    assert contact.brevo_sync_status == CRMSyncStatus.Queued.value
    assert contact.brevo_processing_status == CRMProcessingStatus.Error.value
    assert contact.retry_count == 1
    assert contact.next_retry_at is not None
    assert contact.last_failed_crm == "brevo"


@pytest.mark.asyncio
async def test_brevo_sync_max_retries_exceeded():
    """Test contact marked as Error after max retries"""
    service = BrevoSyncService()

    contact = Contact(
        id="test-uuid",
        email="test@example.com",
        brevo_sync_status="Selected",
        retry_count=3,  # Already at max retries
    )

    session = AsyncMock()

    with patch.object(service, '_sync_to_brevo_api', side_effect=Exception("API Error")):
        await service.process_single_contact(contact, session)

    # Should be marked as Error (no more retries)
    assert contact.brevo_sync_status == CRMSyncStatus.Error.value
    assert contact.brevo_processing_status == CRMProcessingStatus.Error.value
    assert "Max retries exceeded" in contact.brevo_processing_error


@pytest.mark.asyncio
async def test_brevo_sync_no_email():
    """Test contact sync fails gracefully when email missing"""
    service = BrevoSyncService()

    contact = Contact(id="test-uuid", email=None, retry_count=0)
    session = AsyncMock()

    await service.process_single_contact(contact, session)

    # Should retry (not permanent error)
    assert contact.brevo_sync_status == CRMSyncStatus.Queued.value
    assert contact.retry_count == 1
```

**Run tests:**
```bash
pytest tests/services/test_brevo_sync_service.py -v
```

---

#### Manual Testing

**Prerequisites:**
- [ ] Brevo API key configured in `.env`
- [ ] Brevo list ID configured (optional)
- [ ] Application running with scheduler enabled

**Test Steps:**

1. **Mark contact for Brevo sync:**
   ```bash
   curl -X PUT http://localhost:8000/api/v3/contacts/crm/select \
     -H "Authorization: Bearer $JWT_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "contact_ids": ["<uuid>"],
       "crms": ["brevo"],
       "action": "select"
     }'
   ```

2. **Wait for scheduler (5 minutes) or check logs:**
   ```bash
   # Check scheduler logs
   docker compose logs -f app | grep "Brevo sync"
   ```

3. **Verify contact synced:**
   ```sql
   SELECT id, email, brevo_sync_status, brevo_processing_status,
          brevo_contact_id, retry_count
   FROM contacts
   WHERE id = '<uuid>';
   ```

   Expected:
   - `brevo_sync_status = 'Complete'`
   - `brevo_processing_status = 'Complete'`
   - `brevo_contact_id = email address`
   - `retry_count = 0`

4. **Check Brevo dashboard:**
   - Log in to Brevo
   - Navigate to Contacts
   - Search for test email
   - Verify contact exists with attributes

5. **Test retry logic (simulate failure):**
   - Temporarily set invalid API key
   - Mark contact for sync
   - Wait 5 minutes
   - Verify contact status = 'Queued', retry_count = 1, next_retry_at set
   - Restore valid API key
   - Wait for next_retry_at time
   - Verify contact eventually syncs

6. **Test duplicate sync (idempotency):**
   - Sync contact to Brevo (Complete)
   - Mark same contact as 'Selected' again
   - Wait for scheduler
   - Verify contact still Complete, no duplicate in Brevo

---

### 2.6 Phase 2 Testing Gate

**Phase 2 is COMPLETE when:**
- [x] All unit tests pass
- [x] All manual tests pass
- [x] Test contact successfully syncs to Brevo
- [x] Retry logic works (exponential backoff verified)
- [x] Max retries exceeded marks contact as Error
- [x] Idempotency verified (no duplicates in Brevo)
- [x] Phase 1 functionality still works
- [x] Code reviewed by local Claude
- [x] User tested and approved

**DO NOT PROCEED to Phase 3 until all checkboxes above are checked.**

---

### 2.7 Phase 2 Rollback Plan

If Phase 2 needs to be rolled back:

1. **Disable scheduler:**
   ```python
   # In src/scheduler_manager.py
   # Comment out: setup_brevo_sync_scheduler()
   ```

2. **Revert code changes:**
   ```bash
   git revert <phase-2-commit-hash>
   git push
   ```

3. **Reset contact statuses (optional):**
   ```sql
   UPDATE contacts
   SET brevo_sync_status = 'New',
       brevo_processing_status = NULL,
       brevo_processing_error = NULL,
       retry_count = 0,
       next_retry_at = NULL
   WHERE brevo_sync_status != 'Complete';
   ```

4. **Verify rollback:**
   - Scheduler not running (check logs)
   - Phase 1 endpoints still work
   - No API errors

---

## Phase 3: Remaining CRM Services (Days 9-13)

**Goal:** Implement sync services for HubSpot, n8n, Mautic
**Risk Level:** ðŸŸ¡ Medium (follows proven Brevo pattern)
**Deliverable:** All 4 CRMs functional

### 3.1 Implementation Order

1. **HubSpot** (Days 9-10)
   - Fix existing HubSpot implementation to match Brevo pattern
   - Add HubSpot contact ID storage
   - Add retry logic
   - Estimated: 2 days

2. **n8n** (Days 11-12)
   - Copy Brevo pattern
   - Replace Brevo API calls with n8n webhook calls
   - Store n8n workflow execution ID
   - Estimated: 2 days

3. **Mautic** (Day 13)
   - Copy Brevo pattern
   - Replace Brevo API calls with Mautic API calls
   - Store Mautic contact ID
   - Estimated: 1 day

### 3.2 Pattern to Follow

For each CRM, create:
- `src/services/{crm}_sync_service.py` (copy Brevo, replace API calls)
- `src/services/{crm}_sync_scheduler.py` (copy Brevo, change CRM field names)
- Configuration in `src/config/settings.py`
- Tests in `tests/services/test_{crm}_sync_service.py`

**Each CRM must pass its own testing gate before moving to next.**

---

## Phase 4: Advanced Features (Days 14-15)

**Goal:** Polish and production-readiness
**Risk Level:** ðŸŸ¢ Low (optional enhancements)
**Deliverable:** Monitoring, alerting, documentation

### 4.1 Features

1. **Health Check Endpoint**
   - `GET /api/v3/crm/health`
   - Returns scheduler status, queue depths, error rates

2. **Status Dashboard Endpoint**
   - `GET /api/v3/crm/status/summary`
   - Returns count by status for all 4 CRMs

3. **Failed Contact Report**
   - `GET /api/v3/crm/status/failed`
   - Lists all contacts with Error status

4. **Monitoring Queries**
   - Document SQL queries for monitoring
   - Add to HEALTH_CHECKS.md

5. **API Documentation**
   - Update API docs with all new endpoints
   - Add examples and screenshots

---

## Documentation Updates

### Update These Files:

1. **Documentation/Context_Reconstruction/SYSTEM_MAP.md**
   - Add Brevo/Mautic/n8n to External Dependencies section
   - Document CRM sync workflow
   - Add CRM status fields to database table descriptions

2. **Documentation/Context_Reconstruction/HEALTH_CHECKS.md**
   - Add CRM sync health checks
   - Add monitoring queries

3. **Documentation/Work_Orders/WO-015.5_IMPLEMENTATION_COMPLETE.md**
   - Final implementation summary
   - Lessons learned
   - Known issues
   - Future enhancements

4. **README.md** or **API_DOCS.md**
   - Document all new CRM endpoints
   - Add usage examples

---

## Risk Mitigation

### Risk 1: Breaking Existing Functionality
**Mitigation:**
- Comprehensive testing at each phase
- No changes to existing endpoints (only additions)
- Backward compatible database fields (all nullable except status with defaults)

### Risk 2: Brevo API Rate Limits
**Mitigation:**
- Start with batch_size=10, interval=5min (120 contacts/hour max)
- Monitor Brevo API responses for 429 errors
- Document rate limit errors in contact.brevo_processing_error

### Risk 3: Retry Logic Bugs
**Mitigation:**
- Extensive unit tests for retry scenarios
- Manual testing with simulated failures
- Cap retry count at 3 (prevents infinite loops)

### Risk 4: Scheduler Overlap
**Mitigation:**
- Set max_instances=1 in scheduler config
- Use `next_retry_at` field to prevent premature retries
- Scheduler checks `next_retry_at <= NOW()` before processing

### Risk 5: Database Migration Issues
**Mitigation:**
- âœ… Already complete (Phase 1 of WO-015)
- All fields have defaults (backward compatible)
- Can rollback without data loss

---

## Success Criteria (Overall)

**WO-015 is COMPLETE when:**

### Phase 1: Selection Endpoints
- [x] User can select/unselect contacts for all 4 CRMs
- [x] Filter contacts by CRM sync status
- [x] All tests pass
- [x] No breaking changes

### Phase 2: Brevo Sync
- [x] Contacts marked for Brevo automatically sync
- [x] Retry logic works with exponential backoff
- [x] Idempotency verified (no duplicates)
- [x] All tests pass

### Phase 3: Remaining CRMs
- [x] HubSpot fixed and working
- [x] n8n sync working
- [x] Mautic sync working
- [x] All 4 CRMs independently functional

### Phase 4: Polish
- [x] Monitoring endpoints implemented
- [x] Documentation complete
- [x] Health checks documented
- [x] User trained on new features

---

## Timeline Summary

| Phase | Duration | Testing Gate | Can Start |
|-------|----------|--------------|-----------|
| **Phase 1: Selection Endpoints** | 3 days | âœ… Required | Immediately |
| **Phase 2: Brevo Sync** | 5 days | âœ… Required | After Phase 1 âœ… |
| **Phase 3: Remaining CRMs** | 5 days | âœ… Per CRM | After Phase 2 âœ… |
| **Phase 4: Polish** | 2 days | âœ… Required | After Phase 3 âœ… |
| **Total** | **15 days** | **4 gates** | Sequential |

**Critical Path:** Must complete phases in order (1â†’2â†’3â†’4)

---

## Rollback Strategy

Each phase can be independently rolled back:

**Phase 1 Rollback:**
- Revert code changes
- No database changes needed
- Existing endpoints unaffected

**Phase 2 Rollback:**
- Comment out scheduler registration
- Revert code changes
- Reset contact statuses (optional)
- Phase 1 still works

**Phase 3 Rollback:**
- Disable specific CRM scheduler
- Revert code changes for that CRM
- Other CRMs unaffected

**Phase 4 Rollback:**
- Remove monitoring endpoints
- Phases 1-3 unaffected

---

## Next Steps

**Immediate Actions:**
1. âœ… Local Claude reviews this plan
2. âœ… User approves phased approach
3. â­ï¸ Begin Phase 1 implementation
4. â­ï¸ Create Phase 1 testing branch
5. â­ï¸ Implement Phase 1 changes
6. â­ï¸ Run Phase 1 tests
7. â­ï¸ User UAT for Phase 1
8. â­ï¸ Merge Phase 1 to main
9. â­ï¸ Repeat for Phases 2-4

---

## Questions for Local Claude Review

1. **Phase 1 Endpoint Design:** Is the multi-CRM selection endpoint (`/contacts/crm/select`) better than separate endpoints per CRM?

2. **Scheduler Pattern:** Should we use the SDK job loop or custom implementation for Brevo scheduler?

3. **Retry Logic:** Is shared retry tracking (4 fields) across all CRMs the right approach, or should each CRM have its own retry fields?

4. **Testing Strategy:** Are the testing gates sufficient, or should we add more checkpoints?

5. **Error Handling:** Should we implement email notifications for failed syncs now (Phase 2) or later (Phase 4)?

---

**Status:** âœ… Ready for Local Claude Review
**Blocking Issues:** None
**Waiting On:** Local Claude approval + User approval
**Next Document:** WO-015.5_PHASE_1_IMPLEMENTATION.md (after approval)
