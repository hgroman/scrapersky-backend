# WO-016.1: HubSpot CRM Sync Implementation Plan

**Work Order:** WO-016.1
**Created:** 2025-11-18
**Status:** Planning
**Priority:** High
**Depends On:** WO-015 (Brevo sync pattern validated)

---

## Executive Summary

Implement HubSpot CRM contact synchronization following the validated Brevo pattern from WO-015. Leverages existing database schema (18 fields, 2 ENUMs) and dual-status adapter pattern. HubSpot integration requires 2-step upsert pattern (search + create/update) due to API design.

**Key Difference from Brevo:** HubSpot API requires searching for existing contacts by email before creating/updating, rather than a single idempotent POST.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [HubSpot API Overview](#hubspot-api-overview)
3. [Architecture Pattern](#architecture-pattern)
4. [Phase 1: Core Service Implementation](#phase-1-core-service-implementation)
5. [Phase 2: Scheduler Implementation](#phase-2-scheduler-implementation)
6. [Configuration](#configuration)
7. [Testing Strategy](#testing-strategy)
8. [Success Criteria](#success-criteria)
9. [Rollback Plan](#rollback-plan)

---

## Prerequisites

### Database Schema âœ…
Already complete from WO-015.2:

**Contact Model Fields (HubSpot-specific):**
```python
# User Decision (sync_status)
hubspot_sync_status: Mapped[Optional[str]] = mapped_column(String, nullable=True)

# System State (processing_status)
hubspot_processing_status: Mapped[Optional[str]] = mapped_column(String, nullable=True)

# Error Tracking
hubspot_processing_error: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)

# HubSpot Contact ID (numeric string)
hubspot_contact_id: Mapped[Optional[str]] = mapped_column(String, nullable=True)

# Shared Retry Fields (used by all CRMs)
retry_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
next_retry_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
last_retry_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
last_failed_crm: Mapped[Optional[str]] = mapped_column(String, nullable=True)
```

**ENUMs:**
```python
class CRMSyncStatus(str, Enum):
    Selected = "Selected"
    Queued = "Queued"
    Processing = "Processing"
    Complete = "Complete"
    Error = "Error"
    Skipped = "Skipped"

class CRMProcessingStatus(str, Enum):
    Queued = "Queued"
    Processing = "Processing"
    Complete = "Complete"
    Error = "Error"
```

### HubSpot Account Requirements

- [ ] HubSpot account created (free tier sufficient for testing)
- [ ] Private app created in HubSpot developer settings
- [ ] API access token obtained (starts with `pat-na1-` or `pat-eu1-`)
- [ ] Contact write permissions enabled on private app
- [ ] Optional: Portal ID identified (for multi-account scenarios)

**Note:** HubSpot uses "Private Apps" for API authentication, not public API keys like Brevo.

---

## HubSpot API Overview

### Authentication

**Method:** Bearer token authentication

```http
Authorization: Bearer pat-na1-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Content-Type: application/json
```

### Base URLs

**Standard (North America):** `https://api.hubapi.com`
**Europe:** `https://api.hubapi.com` (same, regional routing automatic)

### Core Endpoints

#### 1. Search for Contact by Email
```http
POST /crm/v3/objects/contacts/search
Content-Type: application/json

{
  "filterGroups": [
    {
      "filters": [
        {
          "propertyName": "email",
          "operator": "EQ",
          "value": "user@example.com"
        }
      ]
    }
  ],
  "properties": ["email", "firstname", "lastname", "phone"]
}
```

**Response (Contact Exists):**
```json
{
  "total": 1,
  "results": [
    {
      "id": "12345678901",
      "properties": {
        "email": "user@example.com",
        "firstname": "John",
        "lastname": "Doe"
      }
    }
  ]
}
```

**Response (Contact Not Found):**
```json
{
  "total": 0,
  "results": []
}
```

#### 2. Create New Contact
```http
POST /crm/v3/objects/contacts
Content-Type: application/json

{
  "properties": {
    "email": "user@example.com",
    "firstname": "John",
    "lastname": "Doe",
    "phone": "+1-555-0123",
    "scrapersky_domain_id": "uuid-here",
    "scrapersky_page_id": "uuid-here"
  }
}
```

**Response:**
```json
{
  "id": "12345678901",
  "properties": {
    "email": "user@example.com",
    "createdate": "2025-11-18T10:00:00.000Z",
    "hs_object_id": "12345678901"
  }
}
```

#### 3. Update Existing Contact
```http
PATCH /crm/v3/objects/contacts/{contactId}
Content-Type: application/json

{
  "properties": {
    "firstname": "Jane",
    "lastname": "Smith",
    "phone": "+1-555-9999"
  }
}
```

**Response:**
```json
{
  "id": "12345678901",
  "properties": {
    "email": "user@example.com",
    "firstname": "Jane",
    "lastname": "Smith",
    "lastmodifieddate": "2025-11-18T10:05:00.000Z"
  }
}
```

### Custom Properties

HubSpot requires creating custom properties before use. We'll need:

| Property Name | Type | Description |
|--------------|------|-------------|
| `scrapersky_domain_id` | Single-line text | UUID of source domain |
| `scrapersky_page_id` | Single-line text | UUID of source page |
| `scrapersky_sync_date` | Date | Last sync timestamp |

**Creation via API:**
```http
POST /crm/v3/properties/contacts
{
  "name": "scrapersky_domain_id",
  "label": "ScraperSky Domain ID",
  "type": "string",
  "fieldType": "text",
  "groupName": "contactinformation"
}
```

**Note:** Custom properties can also be created manually via HubSpot UI: Settings â†’ Properties â†’ Contact Properties â†’ Create Property

### Rate Limits

**HubSpot Free/Starter:** 100 requests per 10 seconds
**Professional/Enterprise:** 150 requests per 10 seconds

**Our Approach:** Batch size of 10 contacts per 5-minute cycle = ~0.03 requests/second (well under limits)

### Error Codes

| Code | Meaning | ScraperSky Handling |
|------|---------|---------------------|
| 200 | Success (update) | Mark Complete |
| 201 | Success (create) | Mark Complete |
| 400 | Bad Request (invalid data) | Mark Error, retry with validation |
| 401 | Unauthorized (bad token) | Mark Error, log critical alert |
| 404 | Contact not found (on update) | Retry as create |
| 409 | Conflict (duplicate email) | Search and update instead |
| 429 | Rate limit exceeded | Retry with exponential backoff |

---

## Architecture Pattern

Following validated WO-015 Brevo pattern:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Action (UI/API)                                   â”‚
â”‚  - Marks contact.hubspot_sync_status = 'Queued'         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  APScheduler (every 5 minutes)                          â”‚
â”‚  hubspot_sync_scheduler.py                              â”‚
â”‚  - setup_hubspot_sync_scheduler()                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  process_hubspot_sync_queue()                           â”‚
â”‚  - Query: hubspot_processing_status = 'Queued'          â”‚
â”‚  - Filter: next_retry_at <= NOW()                       â”‚
â”‚  - Batch: 10 contacts (configurable)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  run_job_loop (SDK)                                     â”‚
â”‚  - SELECT FOR UPDATE skip_locked                        â”‚
â”‚  - Bulk mark as 'Processing'                            â”‚
â”‚  - Process individually                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HubSpotSyncService.process_single_contact()            â”‚
â”‚  - Step 1: Search for contact by email                 â”‚
â”‚  - Step 2: Create OR Update based on search result     â”‚
â”‚  - Step 3: Update database status                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Success: hubspot_sync_status = 'Complete'              â”‚
â”‚  Failure: Retry with exponential backoff (max 3)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Differences from Brevo

| Aspect | Brevo | HubSpot |
|--------|-------|---------|
| **Upsert Pattern** | Single POST with `updateEnabled: true` | 2-step: Search â†’ Create/Update |
| **Contact ID** | Email address (string) | Numeric ID (string) |
| **Auth Header** | `api-key: xkeysib-...` | `Authorization: Bearer pat-...` |
| **Custom Fields** | Direct attributes object | Requires pre-created custom properties |
| **Idempotency** | Built-in via `updateEnabled` | Manual via search-first pattern |
| **Name Handling** | `FIRSTNAME`/`LASTNAME` attributes | `firstname`/`lastname` properties (lowercase) |

---

## Phase 1: Core Service Implementation

### Step 1.1: Configuration Setup

**File:** `src/config/settings.py`

Add HubSpot configuration section:

```python
# ============================================================================
# HubSpot CRM Integration (WO-016)
# ============================================================================

# API Authentication
HUBSPOT_API_KEY: Optional[str] = None  # Bearer token (pat-na1-xxx or pat-eu1-xxx)
HUBSPOT_PORTAL_ID: Optional[str] = None  # Optional - for multi-account scenarios

# API Configuration
HUBSPOT_API_BASE_URL: str = "https://api.hubapi.com"

# HubSpot Sync Scheduler (WO-016 Phase 2)
HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES: int = 5
HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE: int = 10
HUBSPOT_SYNC_SCHEDULER_MAX_INSTANCES: int = 1

# HubSpot Retry Logic (WO-016 Phase 2)
HUBSPOT_SYNC_MAX_RETRIES: int = 3
HUBSPOT_SYNC_RETRY_DELAY_MINUTES: int = 5
HUBSPOT_SYNC_RETRY_EXPONENTIAL: bool = True

# Custom Property Names (must match HubSpot property setup)
HUBSPOT_CUSTOM_PROPERTY_DOMAIN_ID: str = "scrapersky_domain_id"
HUBSPOT_CUSTOM_PROPERTY_PAGE_ID: str = "scrapersky_page_id"
HUBSPOT_CUSTOM_PROPERTY_SYNC_DATE: str = "scrapersky_sync_date"
```

**File:** `.env.example`

Add HubSpot section:

```bash
# ============================================================================
# HubSpot CRM Integration (WO-016)
# ============================================================================

# HubSpot API Configuration
HUBSPOT_API_KEY=pat-na1-your-private-app-token-here
HUBSPOT_PORTAL_ID=  # Optional - leave empty unless using multiple accounts
HUBSPOT_API_BASE_URL=https://api.hubapi.com

# HubSpot Sync Scheduler Settings
HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES=5
HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE=10
HUBSPOT_SYNC_SCHEDULER_MAX_INSTANCES=1

# HubSpot Retry Logic Settings
HUBSPOT_SYNC_MAX_RETRIES=3
HUBSPOT_SYNC_RETRY_DELAY_MINUTES=5
HUBSPOT_SYNC_RETRY_EXPONENTIAL=true

# Custom Property Names (must match properties created in HubSpot)
HUBSPOT_CUSTOM_PROPERTY_DOMAIN_ID=scrapersky_domain_id
HUBSPOT_CUSTOM_PROPERTY_PAGE_ID=scrapersky_page_id
HUBSPOT_CUSTOM_PROPERTY_SYNC_DATE=scrapersky_sync_date
```

### Step 1.2: Core Service Implementation

**File:** `src/services/crm/hubspot_sync_service.py`

```python
"""
HubSpot Contact Sync Service (WO-016 Phase 1)

Synchronizes ScraperSky contacts to HubSpot CRM using HubSpot API v3.

Key Features:
- 2-step upsert pattern (search â†’ create/update)
- Exponential backoff retry logic
- Custom property mapping (domain_id, page_id)
- SDK-compatible signature: process_single_contact(contact_id, session)

Architecture Pattern: WO-015 (Brevo) validated pattern
HubSpot API Docs: https://developers.hubspot.com/docs/api/crm/contacts
"""

import logging
from typing import Optional
from uuid import UUID
from datetime import datetime, timedelta

import httpx
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMSyncStatus, CRMProcessingStatus

logger = logging.getLogger(__name__)


class HubSpotSyncService:
    """
    Service for syncing contacts to HubSpot CRM.

    Follows 2-step upsert pattern:
    1. Search for contact by email
    2. Create new contact OR update existing contact

    This is required because HubSpot API doesn't have built-in upsert like Brevo.
    """

    def __init__(self):
        self.api_key = settings.HUBSPOT_API_KEY
        self.base_url = settings.HUBSPOT_API_BASE_URL
        self.portal_id = settings.HUBSPOT_PORTAL_ID

        # Custom property names
        self.prop_domain_id = settings.HUBSPOT_CUSTOM_PROPERTY_DOMAIN_ID
        self.prop_page_id = settings.HUBSPOT_CUSTOM_PROPERTY_PAGE_ID
        self.prop_sync_date = settings.HUBSPOT_CUSTOM_PROPERTY_SYNC_DATE

    async def process_single_contact(
        self, contact_id: UUID, session: AsyncSession
    ) -> None:
        """
        Process a single contact for HubSpot sync.

        SDK-compatible method signature: (contact_id: UUID, session: AsyncSession)
        Called by scheduler via run_job_loop pattern.

        Args:
            contact_id: UUID of contact to sync
            session: Async database session

        Raises:
            Exception: Re-raises all exceptions for SDK error handling
        """
        logger.info(f"ğŸš€ Starting HubSpot sync for contact {contact_id}")

        # Fetch contact from database
        stmt = select(Contact).where(Contact.id == contact_id)
        result = await session.execute(stmt)
        contact = result.scalar_one_or_none()

        if not contact:
            logger.error(f"âŒ Contact {contact_id} not found - skipping")
            return

        try:
            await self._sync_contact_to_hubspot(contact, session)
        except Exception as e:
            logger.exception(f"âŒ Failed to sync contact {contact_id}: {e}")
            raise  # Re-raise for SDK to handle

    async def _sync_contact_to_hubspot(
        self, contact: Contact, session: AsyncSession
    ) -> None:
        """
        Core business logic to sync one contact to HubSpot.

        Flow:
        1. Validate contact has email
        2. Set status to Processing
        3. Search for existing contact in HubSpot
        4. Create new OR update existing contact
        5. Set status to Complete (or Error with retry)

        Args:
            contact: Contact model instance
            session: Async database session
        """
        try:
            # Validation
            if not contact.email:
                raise ValueError("Contact has no email address")

            # Status: Processing
            contact.hubspot_sync_status = CRMSyncStatus.Processing.value
            contact.hubspot_processing_status = CRMProcessingStatus.Processing.value
            await session.commit()

            logger.info(f"ğŸ“§ Syncing {contact.email} to HubSpot")

            # Call HubSpot API (2-step upsert)
            hubspot_contact_id = await self._upsert_contact_to_hubspot(contact)

            # Status: Complete
            contact.hubspot_sync_status = CRMSyncStatus.Complete.value
            contact.hubspot_processing_status = CRMProcessingStatus.Complete.value
            contact.hubspot_processing_error = None
            contact.hubspot_contact_id = hubspot_contact_id
            contact.retry_count = 0
            contact.next_retry_at = None
            await session.commit()

            logger.info(
                f"âœ… HubSpot sync complete for {contact.email} "
                f"(HubSpot ID: {hubspot_contact_id})"
            )

        except Exception as e:
            # Error handling with retry logic
            error_msg = str(e)
            logger.error(f"âŒ HubSpot sync failed for {contact.email}: {error_msg}")

            should_retry = contact.retry_count < settings.HUBSPOT_SYNC_MAX_RETRIES

            if should_retry:
                # Calculate next retry time with exponential backoff
                delay_minutes = self._calculate_retry_delay(contact.retry_count)
                next_retry = datetime.utcnow() + timedelta(minutes=delay_minutes)

                contact.hubspot_sync_status = CRMSyncStatus.Queued.value
                contact.hubspot_processing_status = CRMProcessingStatus.Error.value
                contact.hubspot_processing_error = error_msg[:500]
                contact.retry_count += 1
                contact.next_retry_at = next_retry
                contact.last_retry_at = datetime.utcnow()
                contact.last_failed_crm = "hubspot"

                logger.info(
                    f"ğŸ”„ Retry {contact.retry_count}/{settings.HUBSPOT_SYNC_MAX_RETRIES} "
                    f"scheduled in {delay_minutes} minutes for {contact.email}"
                )
            else:
                # Max retries exceeded - permanent error
                contact.hubspot_sync_status = CRMSyncStatus.Error.value
                contact.hubspot_processing_status = CRMProcessingStatus.Error.value
                contact.hubspot_processing_error = error_msg[:500]
                contact.last_failed_crm = "hubspot"

                logger.error(
                    f"âŒ Max retries exceeded for {contact.email} - "
                    f"marking as permanent error"
                )

            await session.commit()
            raise  # Re-raise for SDK

    async def _upsert_contact_to_hubspot(self, contact: Contact) -> str:
        """
        2-step upsert: Search for existing contact, then create or update.

        HubSpot doesn't have built-in upsert, so we must:
        1. Search for contact by email
        2. If found: Update existing contact
        3. If not found: Create new contact

        Args:
            contact: Contact model instance

        Returns:
            HubSpot contact ID (numeric string like "12345678901")

        Raises:
            httpx.HTTPStatusError: If API call fails
            ValueError: If response is invalid
        """
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }

        async with httpx.AsyncClient(timeout=30.0) as client:
            # Step 1: Search for existing contact by email
            search_payload = {
                "filterGroups": [
                    {
                        "filters": [
                            {
                                "propertyName": "email",
                                "operator": "EQ",
                                "value": contact.email,
                            }
                        ]
                    }
                ],
                "properties": ["email", "firstname", "lastname", "phone"],
            }

            search_response = await client.post(
                f"{self.base_url}/crm/v3/objects/contacts/search",
                headers=headers,
                json=search_payload,
            )

            if search_response.status_code != 200:
                logger.error(
                    f"HubSpot search failed (HTTP {search_response.status_code}): "
                    f"{search_response.text}"
                )
                search_response.raise_for_status()

            search_data = search_response.json()
            existing_contact_id = None

            if search_data.get("total", 0) > 0:
                existing_contact_id = search_data["results"][0]["id"]
                logger.info(
                    f"ğŸ“‹ Found existing HubSpot contact: {existing_contact_id}"
                )

            # Step 2: Build properties object
            properties = self._build_contact_properties(contact)

            # Step 3: Create or Update
            if existing_contact_id:
                # Update existing contact
                update_response = await client.patch(
                    f"{self.base_url}/crm/v3/objects/contacts/{existing_contact_id}",
                    headers=headers,
                    json={"properties": properties},
                )

                if update_response.status_code not in [200, 204]:
                    logger.error(
                        f"HubSpot update failed (HTTP {update_response.status_code}): "
                        f"{update_response.text}"
                    )
                    update_response.raise_for_status()

                logger.info(f"âœ… Updated HubSpot contact {existing_contact_id}")
                return existing_contact_id

            else:
                # Create new contact
                create_response = await client.post(
                    f"{self.base_url}/crm/v3/objects/contacts",
                    headers=headers,
                    json={"properties": properties},
                )

                if create_response.status_code != 201:
                    logger.error(
                        f"HubSpot create failed (HTTP {create_response.status_code}): "
                        f"{create_response.text}"
                    )
                    create_response.raise_for_status()

                create_data = create_response.json()
                new_contact_id = create_data["id"]
                logger.info(f"âœ… Created new HubSpot contact {new_contact_id}")
                return new_contact_id

    def _build_contact_properties(self, contact: Contact) -> dict:
        """
        Build HubSpot properties object from ScraperSky contact.

        Maps ScraperSky fields to HubSpot properties:
        - contact.email â†’ email
        - contact.name â†’ firstname/lastname (split on space)
        - contact.phone_number â†’ phone
        - contact.domain_id â†’ scrapersky_domain_id (custom property)
        - contact.page_id â†’ scrapersky_page_id (custom property)

        Args:
            contact: Contact model instance

        Returns:
            Dictionary of HubSpot properties
        """
        properties = {
            "email": contact.email,
        }

        # Split name into firstname/lastname
        if contact.name:
            name_parts = contact.name.strip().split(maxsplit=1)
            properties["firstname"] = name_parts[0]
            if len(name_parts) > 1:
                properties["lastname"] = name_parts[1]

        # Phone number
        if contact.phone_number:
            properties["phone"] = contact.phone_number

        # Custom ScraperSky properties (must be pre-created in HubSpot)
        if contact.domain_id:
            properties[self.prop_domain_id] = str(contact.domain_id)

        if contact.page_id:
            properties[self.prop_page_id] = str(contact.page_id)

        # Sync timestamp
        properties[self.prop_sync_date] = datetime.utcnow().isoformat()

        return properties

    def _calculate_retry_delay(self, retry_count: int) -> int:
        """
        Calculate retry delay in minutes with exponential backoff.

        Exponential backoff formula: base_delay * 2^retry_count
        - Retry 1: 5 minutes
        - Retry 2: 10 minutes
        - Retry 3: 20 minutes

        Linear fallback: base_delay * (retry_count + 1)

        Args:
            retry_count: Current retry attempt (0-indexed)

        Returns:
            Delay in minutes
        """
        base_delay = settings.HUBSPOT_SYNC_RETRY_DELAY_MINUTES

        if settings.HUBSPOT_SYNC_RETRY_EXPONENTIAL:
            return base_delay * (2**retry_count)
        else:
            return base_delay * (retry_count + 1)
```

**Estimated Lines:** ~350

### Step 1.3: Testing Before Scheduler

Create manual test script to validate core service:

**File:** `test_manual_hubspot_sync.py`

```python
#!/usr/bin/env python3
"""
Manual test script for HubSpot sync core service.
Tests Step 1 (core service) independently of scheduler.
"""

import asyncio
import sys
from uuid import UUID
from src.services.crm.hubspot_sync_service import HubSpotSyncService
from src.session.async_session import get_db_session
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def test_manual_sync(contact_id: str):
    """Manually sync one contact to HubSpot."""
    try:
        contact_uuid = UUID(contact_id)
    except ValueError:
        logger.error(f"âŒ Invalid UUID: {contact_id}")
        return False

    service = HubSpotSyncService()

    if not service.api_key:
        logger.error("âŒ HUBSPOT_API_KEY not configured in .env!")
        return False

    logger.info(f"ğŸ§ª Starting manual sync test for contact: {contact_id}")
    logger.info(f"ğŸ“¡ HubSpot API Base URL: {service.base_url}")

    async for session in get_db_session():
        try:
            await service.process_single_contact(contact_uuid, session)
            logger.info("âœ… MANUAL SYNC COMPLETED SUCCESSFULLY!")
            return True
        except Exception as e:
            logger.exception(f"âŒ MANUAL SYNC FAILED: {e}")
            return False


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python test_manual_hubspot_sync.py <contact_id>")
        sys.exit(1)

    contact_id = sys.argv[1]
    success = asyncio.run(test_manual_sync(contact_id))
    sys.exit(0 if success else 1)
```

---

## Phase 2: Scheduler Implementation

Following exact pattern from WO-015 Brevo scheduler.

### Step 2.1: Create Scheduler File

**File:** `src/services/crm/hubspot_sync_scheduler.py`

```python
"""
HubSpot Contact Sync Scheduler (WO-016 Phase 2)

Background scheduler that automatically processes contacts queued for HubSpot sync.

Architecture: SDK-compatible scheduler using run_job_loop pattern.
Pattern Reference: src/services/WF7_V2_L4_2of2_PageCurationScheduler.py

This scheduler:
1. Runs every N minutes (configured via HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES)
2. Fetches contacts with hubspot_processing_status = 'Queued'
3. Processes each contact via HubSpotSyncService.process_single_contact()
4. Handles retries automatically based on next_retry_at timestamp
"""

import logging
from sqlalchemy import asc, or_
from datetime import datetime

from src.common.curation_sdk.scheduler_loop import run_job_loop
from src.config.settings import settings
from src.models.WF7_V2_L1_1of1_ContactModel import Contact
from src.models.enums import CRMProcessingStatus
from .hubspot_sync_service import HubSpotSyncService

logger = logging.getLogger(__name__)


async def process_hubspot_sync_queue():
    """
    Processes contacts marked as 'Queued' for HubSpot sync using the SDK job loop.

    This function:
    1. Queries contacts with hubspot_processing_status = 'Queued'
    2. Filters for contacts ready for retry (next_retry_at <= now OR next_retry_at IS NULL)
    3. Processes each contact via HubSpotSyncService.process_single_contact()
    4. Automatically handles status transitions via run_job_loop

    Called by: APScheduler at configured interval
    Frequency: HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES (default: 5 minutes)
    Batch Size: HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE (default: 10)
    """
    service = HubSpotSyncService()
    logger.info("ğŸš€ Starting HubSpot sync scheduler cycle")

    await run_job_loop(
        model=Contact,
        status_enum=CRMProcessingStatus,
        queued_status=CRMProcessingStatus.Queued,
        processing_status=CRMProcessingStatus.Processing,
        completed_status=CRMProcessingStatus.Complete,
        failed_status=CRMProcessingStatus.Error,
        processing_function=service.process_single_contact,
        batch_size=settings.HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE,
        order_by_column=asc(Contact.updated_at),
        status_field_name="hubspot_processing_status",
        error_field_name="hubspot_processing_error",
        # Additional filter: Only process contacts ready for retry
        additional_filters=[
            or_(
                Contact.next_retry_at.is_(None),
                Contact.next_retry_at <= datetime.utcnow(),
            )
        ],
    )

    logger.info("âœ… Finished HubSpot sync scheduler cycle")


from src.scheduler_instance import scheduler


def setup_hubspot_sync_scheduler():
    """
    Adds the HubSpot contact sync job to the main scheduler.

    Configuration (from settings.py):
    - HUBSPOT_API_KEY: Required - scheduler will not start if missing
    - HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES: How often to run (default: 5)
    - HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE: Contacts per batch (default: 10)
    - HUBSPOT_SYNC_SCHEDULER_MAX_INSTANCES: Concurrent instances (default: 1)

    Safety:
    - Scheduler disabled if HUBSPOT_API_KEY not configured
    - max_instances=1 prevents race conditions
    - misfire_grace_time=1800 (30min) handles temporary downtime
    """
    # Safety check: Don't start scheduler if API key not configured
    if not settings.HUBSPOT_API_KEY:
        logger.warning(
            "âš ï¸ HUBSPOT_API_KEY not configured - HubSpot sync scheduler DISABLED"
        )
        logger.warning("   Set HUBSPOT_API_KEY in .env to enable automatic HubSpot sync")
        return

    logger.info("ğŸ“‹ Configuring HubSpot sync scheduler...")
    logger.info(
        f"   Interval: {settings.HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES} minutes"
    )
    logger.info(f"   Batch size: {settings.HUBSPOT_SYNC_SCHEDULER_BATCH_SIZE} contacts")
    logger.info(f"   Max instances: {settings.HUBSPOT_SYNC_SCHEDULER_MAX_INSTANCES}")

    scheduler.add_job(
        process_hubspot_sync_queue,
        trigger="interval",
        minutes=settings.HUBSPOT_SYNC_SCHEDULER_INTERVAL_MINUTES,
        id="hubspot_contact_sync_processor",
        name="HubSpot Contact Sync Processor",
        replace_existing=True,
        max_instances=settings.HUBSPOT_SYNC_SCHEDULER_MAX_INSTANCES,
        misfire_grace_time=1800,  # 30 minutes grace time for temporary downtime
    )

    logger.info("âœ… HubSpot sync scheduler job registered successfully")
```

**Estimated Lines:** ~120

### Step 2.2: Register Scheduler in main.py

**File:** `src/main.py`

Add import (near line 33):
```python
from src.services.crm.brevo_sync_scheduler import setup_brevo_sync_scheduler
from src.services.crm.hubspot_sync_scheduler import setup_hubspot_sync_scheduler
```

Add setup call in lifespan function (after Brevo setup, around line 148):
```python
    # WO-015: Brevo CRM sync scheduler
    try:
        setup_brevo_sync_scheduler()
    except Exception as e:
        logger.error(f"Failed to setup Brevo Sync scheduler job: {e}", exc_info=True)

    # WO-016: HubSpot CRM sync scheduler
    try:
        setup_hubspot_sync_scheduler()
    except Exception as e:
        logger.error(f"Failed to setup HubSpot Sync scheduler job: {e}", exc_info=True)
```

---

## Configuration

### HubSpot Private App Setup

**Step-by-step guide for obtaining API key:**

1. **Log into HubSpot**
   - Go to https://app.hubspot.com/
   - Navigate to Settings (gear icon) â†’ Integrations â†’ Private Apps

2. **Create Private App**
   - Click "Create a private app"
   - Name: "ScraperSky Contact Sync"
   - Description: "Automated contact synchronization from ScraperSky platform"

3. **Configure Scopes**
   Enable the following scopes:
   - `crm.objects.contacts.read` (Search for existing contacts)
   - `crm.objects.contacts.write` (Create/update contacts)
   - `crm.schemas.contacts.read` (Read custom properties)
   - `crm.schemas.contacts.write` (Create custom properties via API - optional)

4. **Generate Token**
   - Click "Create app"
   - Copy the access token (starts with `pat-na1-` or `pat-eu1-`)
   - **IMPORTANT:** Save this token securely - it's only shown once!

5. **Add to .env**
   ```bash
   HUBSPOT_API_KEY=pat-na1-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
   ```

### Custom Properties Setup

**Option A: Manual Setup (Recommended for first-time)**

1. Go to Settings â†’ Properties â†’ Contact Properties
2. Click "Create property"
3. Create 3 properties:

| Field | Value |
|-------|-------|
| **Property 1** | |
| Label | ScraperSky Domain ID |
| Internal name | scrapersky_domain_id |
| Type | Single-line text |
| Group | Contact Information |
| **Property 2** | |
| Label | ScraperSky Page ID |
| Internal name | scrapersky_page_id |
| Type | Single-line text |
| Group | Contact Information |
| **Property 3** | |
| Label | ScraperSky Sync Date |
| Internal name | scrapersky_sync_date |
| Type | Date picker |
| Group | Contact Information |

**Option B: API Setup (Advanced)**

```bash
# Create custom property via API
curl -X POST \
  https://api.hubapi.com/crm/v3/properties/contacts \
  -H "Authorization: Bearer pat-na1-YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "scrapersky_domain_id",
    "label": "ScraperSky Domain ID",
    "type": "string",
    "fieldType": "text",
    "groupName": "contactinformation"
  }'
```

---

## Testing Strategy

### Unit Tests (Optional - Manual Testing Sufficient)

Test individual methods:
- `_build_contact_properties()` - Property mapping
- `_calculate_retry_delay()` - Exponential backoff
- `_upsert_contact_to_hubspot()` - Search + create/update logic

### Integration Test Plan

Follow WO-015.10 pattern adapted for HubSpot:

**Test Contacts:**
1. Fresh contact (never synced)
2. Contact with domain/page metadata
3. Contact for scheduler test
4. Invalid email for retry test

**Test Phases:**
1. Manual sync test (Core Service)
2. Scheduler automatic sync test
3. Retry logic validation (exponential backoff)
4. HubSpot dashboard verification
5. Error handling test (invalid token)

**Detailed Test Plan:** Create WO-016.2_HUBSPOT_INTEGRATION_TEST_PLAN.md after implementation.

---

## Success Criteria

- [ ] Configuration added to `settings.py` and `.env.example`
- [ ] `HubSpotSyncService` class created with 2-step upsert logic
- [ ] Manual test script works with real HubSpot API
- [ ] `hubspot_sync_scheduler.py` created following WF7 pattern
- [ ] Scheduler registered in `main.py`
- [ ] Docker Compose starts without errors
- [ ] Scheduler logs show successful registration
- [ ] Manual sync creates contact in HubSpot
- [ ] Scheduler automatically processes queued contacts
- [ ] Retry logic works with exponential backoff
- [ ] Custom properties (domain_id, page_id) sync correctly
- [ ] Error handling works for invalid token (401)
- [ ] All code passes linting and formatting

---

## Rollback Plan

If issues arise during implementation:

1. **Code Rollback:**
   ```bash
   git revert <commit-hash>
   git push
   ```

2. **Disable Scheduler:**
   Edit `.env`:
   ```bash
   HUBSPOT_API_KEY=  # Empty to disable
   ```
   Restart Docker:
   ```bash
   docker compose restart app
   ```

3. **Database Cleanup (if needed):**
   ```sql
   -- Reset all HubSpot sync attempts
   UPDATE contacts
   SET hubspot_sync_status = NULL,
       hubspot_processing_status = NULL,
       hubspot_processing_error = NULL,
       hubspot_contact_id = NULL,
       retry_count = 0,
       next_retry_at = NULL
   WHERE hubspot_sync_status IS NOT NULL;
   ```

---

## Implementation Checklist

### Phase 1: Core Service
- [ ] Add configuration to `src/config/settings.py`
- [ ] Add HubSpot section to `.env.example`
- [ ] Create `src/services/crm/hubspot_sync_service.py`
- [ ] Implement `HubSpotSyncService` class
- [ ] Implement `_upsert_contact_to_hubspot()` (2-step pattern)
- [ ] Implement `_build_contact_properties()` mapping
- [ ] Implement `_calculate_retry_delay()` logic
- [ ] Create `test_manual_hubspot_sync.py` script
- [ ] Run linting and formatting
- [ ] Manual test with real HubSpot API
- [ ] Commit and push Phase 1

### Phase 2: Scheduler
- [ ] Create `src/services/crm/hubspot_sync_scheduler.py`
- [ ] Implement `process_hubspot_sync_queue()` function
- [ ] Implement `setup_hubspot_sync_scheduler()` function
- [ ] Add import to `src/main.py`
- [ ] Add setup call to `src/main.py` lifespan
- [ ] Run linting and formatting
- [ ] Test scheduler registration in Docker
- [ ] Verify scheduler processes contacts automatically
- [ ] Commit and push Phase 2

### Testing & Documentation
- [ ] Create comprehensive integration test plan (WO-016.2)
- [ ] Test manual sync (Step 1)
- [ ] Test automatic scheduler (Step 2)
- [ ] Test retry logic with exponential backoff
- [ ] Verify HubSpot dashboard shows synced contacts
- [ ] Test error handling (invalid token)
- [ ] Document any HubSpot-specific gotchas
- [ ] Final commit and push

---

## Timeline Estimate

| Phase | Duration | Description |
|-------|----------|-------------|
| Phase 1: Core Service | 2-3 hours | Configuration + service implementation + manual testing |
| Phase 2: Scheduler | 1 hour | Scheduler + registration + integration testing |
| Testing & Documentation | 1-2 hours | Comprehensive test plan + validation |
| **TOTAL** | **4-6 hours** | Complete HubSpot integration |

---

## Related Documents

- **WO-015.2:** Database migration (completed - 18 fields, 2 ENUMs)
- **WO-015.8:** Brevo implementation plan (pattern reference)
- **WO-015.10:** Brevo integration test plan (pattern for WO-016.2)
- **WO-016.2:** HubSpot integration test plan (to be created after implementation)

---

## Notes

### HubSpot API Quirks

1. **Numeric Contact IDs:** HubSpot uses numeric IDs (e.g., "12345678901") vs. Brevo's email-based IDs
2. **Search Required:** No built-in upsert - must search first to avoid duplicates
3. **Custom Properties:** Must be created before use (via UI or API)
4. **Bearer Token:** Uses standard OAuth Bearer token format vs. Brevo's custom `api-key` header
5. **Rate Limits:** More generous than Brevo (100-150 req/10sec vs. Brevo's stricter limits)
6. **Property Names:** Lowercase convention (`firstname` not `FIRSTNAME`)

### Future Enhancements (Out of Scope for WO-016)

- Deal/Company association (requires additional HubSpot objects)
- List membership management
- Lifecycle stage tracking
- Custom event tracking (page views, form submissions)
- Webhook integration for bidirectional sync

---

**Document Status:** Planning Complete - Ready for Implementation
**Next Step:** Implement Phase 1 (Core Service)
**Approval:** Pending user confirmation to proceed

---

**END OF IMPLEMENTATION PLAN**
