# Supabase MCP Troubleshooting Guide

This troubleshooting guide addresses common issues that may arise when using Supabase MCP for database migrations in the ScraperSky project. It provides solutions, workarounds, and helpful patterns to ensure smooth schema management.

## Table of Contents

1. [Common Errors and Solutions](#common-errors-and-solutions)
2. [Local Development Environment Issues](#local-development-environment-issues)
3. [Production Migration Challenges](#production-migration-challenges)
4. [MCP Integration with Windsurf/Cursor](#mcp-integration-with-windsurfcursor)
5. [Schema Migration Examples](#schema-migration-examples)
6. [Advanced Error Recovery](#advanced-error-recovery)

## Common Errors and Solutions

### Error: "Failed to parse connection string"

**Error message:**
```
failed to parse connection string: cannot parse `postgresql+asyncpg://...`: failed to parse as DSN (invalid dsn)
```

**Cause:** Supabase CLI expects a standard PostgreSQL connection string, but our project uses SQLAlchemy async connection strings.

**Solution:**
1. Create a standard PostgreSQL connection string for migrations:
   ```
   postgresql://postgres.PROJECT_REF:PASSWORD@aws-0-us-west-1.pooler.supabase.com:6543/postgres
   ```
2. Store this connection string as `SUPABASE_DB_URL` in your environment or CI/CD secrets.

### Error: "The remote database's migration history does not match local files"

**Cause:** Local migration files don't match the database's `schema_migrations` table.

**Solution:**
1. First try pulling the remote schema: `supabase db pull`
2. If that fails, repair the migration history:
   ```bash
   supabase migration repair --status applied [MIGRATION_ID]
   ```
   Replace `[MIGRATION_ID]` with the timestamp in your migration filename (e.g., `20250507120000`).

### Error: "Schema initialization error" with local DB reset

**Cause:** Issues with the local Docker container setup.

**Solution:**
1. Stop Supabase: `supabase stop`
2. Start Supabase again: `supabase start`
3. If issues persist, reset the Supabase setup:
   ```bash
   rm -rf supabase/volumes
   supabase start
   ```

## Local Development Environment Issues

### Connecting to Local Supabase Instance

The local Supabase database runs inside Docker containers. To connect directly:

```bash
# Connect to PostgreSQL container
docker exec -it supabase_db_scraper-sky-backend psql -U postgres
```

### Verifying Migration Status Locally

```sql
-- Check applied migrations
SELECT * FROM supabase_migrations.schema_migrations ORDER BY version ASC;

-- Check enum types
SELECT
    t.typname AS enum_name,
    array_agg(e.enumlabel ORDER BY e.enumsortorder) AS enum_values
FROM
    pg_type t
JOIN
    pg_enum e ON t.oid = e.enumtypid
GROUP BY
    t.typname;
```

### Handling Migration Filename Conflicts

If you encounter errors due to migration timestamp conflicts:

1. Check existing migrations: `ls -la supabase/migrations/`
2. Create a new migration with a later timestamp:
   ```bash
   touch supabase/migrations/$(date +"%Y%m%d%H%M%S")_your_description.sql
   ```

## Production Migration Challenges

### Dealing with Migration Failures

If a migration fails in production:

1. Check the error logs in your CI/CD pipeline
2. Connect to the production database (via secure method)
3. Check the migration status:
   ```sql
   SELECT * FROM supabase_migrations.schema_migrations ORDER BY version DESC LIMIT 5;
   ```
4. Create a new corrective migration locally and test carefully
5. Push the fixed migration through your CI/CD pipeline

### Rolling Back Migrations

**Important:** Supabase MCP doesn't support automatic rollbacks. You must:

1. Create a new migration that reverses the changes of the problematic migration
2. Apply this rollback migration through CI/CD or manually
3. Example rollback migration:
   ```sql
   -- Rollback for migration 20250507161500_add_analytics_events_table.sql
   DROP TABLE IF EXISTS analytics_events;
   ```

## MCP Integration with Windsurf/Cursor

### MCP Configuration Troubleshooting

If MCP isn't working in Windsurf/Cursor:

1. Check your `.cursor/mcp.json` file:
   ```json
   {
     "mcpServers": {
       "supabase": {
         "command": "npx",
         "args": [
           "-y",
           "@supabase/mcp-server-supabase@0.3.0",
           "--access-token",
           "YOUR_SUPABASE_ACCESS_TOKEN"
         ]
       }
     }
   }
   ```

2. Verify the access token is valid
3. Restart Windsurf/Cursor
4. Check for MCP server errors in the output panel

### Natural Language Prompt Issues

If your natural language prompts aren't producing expected SQL:

1. Be more specific in your prompt
2. Mention table fields explicitly
3. Include constraints and relationships
4. Specify the desired SQL dialect (PostgreSQL)
5. Reference existing table structures

## Schema Migration Examples

### Example 1: Adding Contact Curation Fields

This example demonstrates adding standard curation and processing fields to the `contacts` table similar to what was done for the `pages` table.

**Workflow Information:**
- Workflow name: `contact_curation`
- Source table: `contacts`
- Operation: Adding status tracking fields

**MCP Natural Language Prompt:**
```
Create a migration that:

1. Creates two new enum types:
   - contactcurationstatus with values ('New', 'Queued', 'Processing', 'Complete', 'Error', 'Skipped')
   - contactprocessingstatus with values ('Queued', 'Processing', 'Complete', 'Error')

2. Adds three new columns to the contacts table:
   - contact_curation_status of type contactcurationstatus, not null, with default 'New'
   - contact_processing_status of type contactprocessingstatus, nullable
   - contact_processing_error of type TEXT, nullable

3. Creates indexes on the new status columns.
```

**Expected SQL Output (Migration File: `20250507162800_add_contact_curation_fields.sql`):**
```sql
-- Migration: Add contact curation workflow fields
-- Created with Supabase MCP: 2025-05-07

-- Step 1: Create required enum types
CREATE TYPE contactcurationstatus AS ENUM ('New', 'Queued', 'Processing', 'Complete', 'Error', 'Skipped');
CREATE TYPE contactprocessingstatus AS ENUM ('Queued', 'Processing', 'Complete', 'Error');

-- Step 2: Add the necessary columns to the contacts table
ALTER TABLE contacts ADD COLUMN contact_curation_status contactcurationstatus NOT NULL DEFAULT 'New';
ALTER TABLE contacts ADD COLUMN contact_processing_status contactprocessingstatus;
ALTER TABLE contacts ADD COLUMN contact_processing_error TEXT;

-- Step 3: Create indexes for status fields to improve query performance
CREATE INDEX idx_contacts_contact_curation_status ON contacts(contact_curation_status);
CREATE INDEX idx_contacts_contact_processing_status ON contacts(contact_processing_status);

-- Add comments for documentation
COMMENT ON COLUMN contacts.contact_curation_status IS 'Current curation status for the contact workflow';
COMMENT ON COLUMN contacts.contact_processing_status IS 'Current processing status for the contact workflow';
COMMENT ON COLUMN contacts.contact_processing_error IS 'Error message if processing failed';
```

### SQLAlchemy Model Updates

After applying the migration, update the SQLAlchemy model in `src/models/contact.py`:

```python
from enum import Enum
import sqlalchemy as sa
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.dialects.postgresql import ENUM as PgEnum

from ..db.base_class import Base

# Standard workflow status enums
class ContactCurationStatus(str, Enum):
    New = "New"
    Queued = "Queued"
    Processing = "Processing"
    Complete = "Complete"
    Error = "Error"
    Skipped = "Skipped"

class ContactProcessingStatus(str, Enum):
    Queued = "Queued"
    Processing = "Processing"
    Complete = "Complete"
    Error = "Error"

class Contact(Base):
    __tablename__ = "contacts"

    # Existing fields...

    # New fields for the contact_curation workflow
    contact_curation_status: Mapped[ContactCurationStatus] = mapped_column(
        PgEnum(ContactCurationStatus, name="contactcurationstatus", create_type=False),
        nullable=False,
        default=ContactCurationStatus.New,
        server_default=ContactCurationStatus.New.value,
        index=True
    )
    contact_processing_status: Mapped[ContactProcessingStatus] = mapped_column(
        PgEnum(ContactProcessingStatus, name="contactprocessingstatus", create_type=False),
        nullable=True,
        index=True
    )
    contact_processing_error: Mapped[str] = mapped_column(
        sa.Text,
        nullable=True
    )
```

## Advanced Error Recovery

### Recovering from Failed MCP Server Launch

If Windsurf/Cursor fails to launch the MCP server:

1. Check the Node.js installation: `node --version`
2. Try running MCP manually:
   ```bash
   npx -y @supabase/mcp-server-supabase@0.3.0 --access-token YOUR_TOKEN
   ```
3. Check network access to Supabase API
4. Reinstall the MCP package:
   ```bash
   npm uninstall -g @supabase/mcp-server-supabase
   npm install -g @supabase/mcp-server-supabase@0.3.0
   ```

### Handling "Unknown command" Errors

If you encounter "unknown command" errors:

1. Verify Supabase CLI version: `supabase --version`
2. Update if needed: `brew upgrade supabase/tap/supabase`
3. Check command syntax against the latest documentation
4. Run with debug flag: `supabase db push --debug`

### PostgreSQL Schema Conflicts

If migrations fail due to schema conflicts:

1. Connect to the database and check the current schema
2. Create a conditional migration that checks for existence before making changes:
   ```sql
   -- Check if enum already exists
   DO $$
   BEGIN
       IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'contactcurationstatus') THEN
           CREATE TYPE contactcurationstatus AS ENUM ('New', 'Queued', 'Processing', 'Complete', 'Error', 'Skipped');
       END IF;
   END$$;

   -- Check if column already exists
   DO $$
   BEGIN
       IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                      WHERE table_name='contacts' AND column_name='contact_curation_status') THEN
           ALTER TABLE contacts ADD COLUMN contact_curation_status contactcurationstatus NOT NULL DEFAULT 'New';
       END IF;
   END$$;
   ```

## Final Recommendations

1. **Always test migrations locally** before applying to production
2. **Use meaningful timestamps** in migration filenames for proper ordering
3. **Maintain a detailed migration log** for your project
4. **Create incremental migrations** rather than large schema changes
5. **Backup your database** before applying migrations to production

For more information, refer to:
- [MCP-MIGRATION-GUIDE.md](./MCP-MIGRATION-GUIDE.md)
- [MCP-MIGRATION-EXAMPLE.md](./MCP-MIGRATION-EXAMPLE.md)
- [Official Supabase Documentation](https://supabase.com/docs/guides/database/migrations)
