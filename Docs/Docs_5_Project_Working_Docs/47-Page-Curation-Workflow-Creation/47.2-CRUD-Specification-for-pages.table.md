# CRUD Specification for `pages` Table

**Date:** May 5, 2025
**Author:** Gemini Assistant
**Status:** Draft

## 1. Overview

This document specifies the requirements for API endpoints providing Create, Read, Update (CRUD-like) operations for the `pages` database table, primarily focused on supporting a UI data grid for page curation. The design will mirror the patterns established in Workflows WF2, WF3, WF4, and WF5.

## 2. Target Model and Enums

- **Primary Model:** `Page`
  - **File Path:** `src/models/page.py` (Assumption, verify path)
  - **Table Name:** `pages`
  - **Key Fields (Assumed):**
    - `id` (UUID, PK)
    - `sitemap_file_id` (UUID, FK to `sitemap_files`)
    - `url` (Text)
    - `status` (Enum, e.g., `PageCurationStatus`) - Primary status for UI curation.
    - `processing_status` (Enum, e.g., `PageProcessingStatus`) - Secondary status for triggering background tasks.
    - `last_processed_at` (DateTime)
    - `processing_error` (Text)
    - `created_at` (DateTime)
    - `updated_at` (DateTime)
    - `tenant_id` (UUID)
- **Enums:**
  - `PageCurationStatus` (Assumption, define values: e.g., New, Selected, Rejected, Archived)
  - `PageProcessingStatus` (Assumption, define values: e.g., Queued, Processing, Completed, Error)
  - API Enums (in `src/models/api_models.py`) corresponding to the above for request validation.

## 3. API Endpoints

A new router will be created, likely `src/routers/pages.py`.

### 3.1 List Pages (Read)

- **Endpoint:** `GET /api/v3/pages` (Note: No trailing slash)
- **Response Model:** `PaginatedPageResponse` (Pydantic model containing `items: List[PageRecord]`, `total`, `page`, `size`, `pages`)
  - `PageRecord` (Pydantic model mirroring relevant `Page` fields for the UI grid)
- **Query Parameters:**
  - `page: int` (Default: 1, Min: 1)
  - `size: int` (Default: 50, Min: 1, Max: 200)
  - `status: Optional[PageCurationStatus]` (Filter by primary curation status)
  - `url_contains: Optional[str]` (Filter by case-insensitive substring match on `url`)
  - `sitemap_file_id: Optional[UUID]` (Filter by parent sitemap file)
  - `processing_status: Optional[PageProcessingStatus]` (Filter by secondary processing status)
  - `sort_by: Optional[str]` (Default: `updated_at`, Allow: `url`, `status`, `updated_at`, etc.)
  - `sort_dir: Optional[str]` (Default: `desc`, Allow: `asc`, `desc`)
- **Logic:**
  - Authenticate using `get_current_user`.
  - Get `tenant_id` from user.
  - Use SQLAlchemy ORM (`select(Page)...`) to query the `pages` table.
  - Apply filters based on query parameters AND `tenant_id`.
  - **Crucially:** Calculate total count using a separate ORM query (`select(func.count())...`), applying the _same_ filters correctly (mirroring `local_businesses.py` pattern).
  - Apply sorting and pagination to the main data query.
  - Return data using the `PaginatedPageResponse` model.

### 3.2 Batch Update Page Status (Update)

- **Endpoint:** `PUT /api/v3/pages/status`
- **Request Body Model:** `PageBatchStatusUpdateRequest` (Pydantic model)
  - `page_ids: List[UUID]` (List of `Page` IDs to update)
  - `status: PageCurationStatus` (Target primary curation status - use API Enum)
- **Response Model:** `Dict[str, int]` (e.g., `{"updated_count": N, "queued_count": M}`)
- **Logic:**
  - Authenticate using `get_current_user`.
  - Get `user_id` and `tenant_id` from user.
  - Validate `request_body` using Pydantic model.
  - Map API status Enum to database Enum (`PageCurationStatus`).
  - Start database transaction (`async with session.begin():`).
  - Fetch `Page` ORM objects matching `page_ids` and `tenant_id`.
  - Iterate through fetched objects:
    - Update the primary `status` field.
    - **Dual-Status Logic:** If the new primary status is `Selected` (or equivalent trigger value), update the secondary `processing_status` field to `Queued` (or equivalent) and clear any previous `processing_error`. Increment `queued_count`.
    - Increment `updated_count`.
  - Transaction commits automatically on successful exit from `begin()` block; rollbacks on exception.
  - Return `updated_count` and `queued_count`.

## 4. Key Implementation Notes

- Strict adherence to **ORM-only** database access is required.
- The router (`src/routers/pages.py`) will own the transaction boundary for the `PUT /status` endpoint.
- Filtering logic for the `GET /` endpoint must correctly apply filters to both the data query and the count query.
- Use standard dependency injection for session (`get_db_session`) and user (`get_current_user`).
- Ensure appropriate logging is added.

## 5. Open Questions/TODOs

- [ ] Verify exact path for `src/models/page.py`.
- [ ] Confirm exact names and values for `PageCurationStatus` and `PageProcessingStatus` Enums.
- [ ] Define the specific list of allowed fields for `sort_by`.
- [ ] Create corresponding Pydantic models (`PaginatedPageResponse`, `PageRecord`, `PageBatchStatusUpdateRequest`, API Enums).
- [ ] Implement the actual router (`src/routers/pages.py`) and potentially a service layer if needed.
